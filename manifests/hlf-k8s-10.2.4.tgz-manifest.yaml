---
# Source: hlf-k8s/charts/couchdb/templates/networkpolicy.yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: my-release-couchdb
  labels:
    app: couchdb
    chart: couchdb-3.3.4
    release: my-release
    heritage: Helm
spec:
  podSelector:
    matchLabels:
      app: couchdb
      release: my-release
  ingress:
    - ports:
        - protocol: TCP
          port: 5984
    - ports:
        - protocol: TCP
          port: 9100
        - protocol: TCP
          port: 4369
      from:
        - podSelector:
            matchLabels:
              app: couchdb
              release: my-release
  policyTypes:
    - Ingress
---
# Source: hlf-k8s/charts/couchdb/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-release-couchdb
  labels:
    app: couchdb
    chart: couchdb-3.3.4
    release: my-release
    heritage: Helm
---
# Source: hlf-k8s/templates/rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-release-hlf-k8s
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
    app.kubernetes.io/part-of: hlf-k8s
---
# Source: hlf-k8s/charts/couchdb/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-release-couchdb
  labels:
    app: my-release-couchdb
    chart: "couchdb-3.3.4"
    release: "my-release"
    heritage: "Helm"
type: Opaque
data:
  adminUsername: "Y291Y2hkYg=="
  adminPassword: "Y291Y2hkYnB3ZA=="
  cookieAuthSecret: "anpwTlV4d0pBYXM4cVBSakNQeGM="
---
# Source: hlf-k8s/charts/hlf-ca/templates/secret--ca.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-release-hlf-ca--ca
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
type: Opaque
data:
  CA_ADMIN: "Y2FBZG1pbg=="
  
  CA_PASSWORD:  "Y2FQYXNzd29yZA=="
---
# Source: hlf-k8s/templates/secret-couchdb-credentials.yaml
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: my-release-hlf-k8s-couchdb-credentials
data:
  COUCHDB_USER: Y291Y2hkYg==
  COUCHDB_PASSWORD: Y291Y2hkYnB3ZA==
---
# Source: hlf-k8s/charts/couchdb/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-couchdb
  labels:
    app: couchdb
    chart: "couchdb-3.3.4"
    heritage: "Helm"
    release: "my-release"
data:
  inifile: |
    [chttpd]
    bind_address = any
    require_valid_user = false
    
    [couchdb]
    uuid = d3cefce1-8736-41ef-8468-27bf6cd035ec
    
    

  seedlistinifile: |
    [cluster]
    seedlist = couchdb@my-release-couchdb-0.my-release-couchdb.default.svc.cluster.local
---
# Source: hlf-k8s/charts/hlf-ca/templates/configmap--ca.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-ca--ca
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
data:
  GODEBUG: "netdns=go"
  FABRIC_CA_HOME: /var/hyperledger/fabric-ca
  FABRIC_CA_SERVER_CA_NAME: "rca"
  SERVICE_DNS: 0.0.0.0  # Point to itself
---
# Source: hlf-k8s/charts/hlf-ca/templates/configmap--config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-ca--config
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
data:
  ca.yaml: |
    #############################################################################
    #   This is a configuration file for the fabric-ca-server command.
    #############################################################################
    # Version of config file
    version: 1.5.0
    # Server's listening port
    port: 7054
    # Enables debug logging
    debug: true
    # Size limit of an acceptable CRL in bytes (default: 512000)
    crlsizelimit: 512000
    #############################################################################
    #  TLS section
    #############################################################################
    tls:
      # Enable TLS (handled by the Ingress)
      enabled: false
      # TLS for the server's listening port
      certfile: /var/hyperledger/tls/secret/tls.crt
      keyfile: /var/hyperledger/tls/secret/tls.key
      clientauth:
        # Supported types: NoClientCert, RequestClientCert, RequireAnyClientCert, VerifyClientCertIfGiven and RequireAndVerifyClientCert.
        type: noclientcert
        # List of root certificate authorities used when verifying client certificates
        certfiles:
    #############################################################################
    #  The CA section contains information related to the Certificate Authority
    #  including the name of the CA, which should be unique for all members
    #  of a blockchain network.  It also includes the key and certificate files
    #  used when issuing enrollment certificates (ECerts) and transaction
    #  certificates (TCerts).
    #  The chainfile (if it exists) contains the certificate chain which
    #  should be trusted for this CA, where the 1st in the chain is always the
    #  root CA certificate.
    #############################################################################
    ca:
      # Name of this CA
      name:
      # Key file (is only used to import a private key into BCCSP)
      keyfile:
      # Certificate file (default: ca-cert.pem)
      certfile: /var/hyperledger/fabric-ca/msp/certs/my-release-hlf-ca-cert.pem
      # Chain file
      chainfile:
      # Ignore Certificate Expiration in the case of re-enroll
      reenrollIgnoreCertExpiry: true
    #############################################################################
    #  The gencrl REST endpoint is used to generate a CRL that contains revoked
    #  certificates. This section contains configuration options that are used
    #  during gencrl request processing.
    #############################################################################
    crl:
      # Specifies expiration for the generated CRL. The number of hours
      # specified by this property is added to the UTC time, the resulting time
      # is used to set the 'Next Update' date of the CRL.
      expiry: 24h
    #############################################################################
    #  The registry section controls how the fabric-ca-server does two things:
    #  1) authenticates enrollment requests which contain a username and password
    #     (also known as an enrollment ID and secret).
    #  2) once authenticated, retrieves the identity's attribute names and
    #     values which the fabric-ca-server optionally puts into TCerts
    #     which it issues for transacting on the Hyperledger Fabric blockchain.
    #     These attributes are useful for making access control decisions in
    #     chaincode.
    #  There are two main configuration options:
    #  1) The fabric-ca-server is the registry.
    #     This is true if "ldap.enabled" in the ldap section below is false.
    #  2) An LDAP server is the registry, in which case the fabric-ca-server
    #     calls the LDAP server to perform these tasks.
    #     This is true if "ldap.enabled" in the ldap section below is true,
    #     which means this "registry" section is ignored.
    #############################################################################
    registry:
      # Maximum number of times a password/secret can be reused for enrollment
      # (default: -1, which means there is no limit)
      maxenrollments: -1
      # Contains identity information which is used when LDAP is disabled
      identities:
         - name: <<<ADMIN>>>
           pass: <<<ADMINPW>>>
           type: client
           affiliation: ""
           attrs:
              hf.Registrar.Roles: "peer,orderer,client,user"
              hf.Registrar.DelegateRoles: "peer,orderer,client,user"
              hf.Revoker: true
              hf.IntermediateCA: true
              hf.GenCRL: true
              hf.Registrar.Attributes: "*"
              hf.AffiliationMgr: true
    #############################################################################
    #  Database section
    #  Supported types are: "sqlite3", "postgres", and "mysql".
    #  The datasource value depends on the type.
    #  If the type is "sqlite3", the datasource value is a file name to use
    #  as the database store.  Since "sqlite3" is an embedded database, it
    #  may not be used if you want to run the fabric-ca-server in a cluster.
    #  To run the fabric-ca-server in a cluster, you must choose "postgres"
    #  or "mysql".
    #############################################################################
    db:
      type: <<<DB_TYPE>>>
      datasource: <<<DB_DATASOURCE>>>
      tls:
          enabled: false
          certfiles:
          client:
            certfile:
            keyfile:
    #############################################################################
    #  LDAP section
    #  If LDAP is enabled, the fabric-ca-server calls LDAP to:
    #  1) authenticate enrollment ID and secret (i.e. username and password)
    #     for enrollment requests;
    #  2) To retrieve identity attributes
    #############################################################################
    ldap:
       # Enables or disables the LDAP client (default: false)
       # If this is set to true, the "registry" section is ignored.
       enabled: false
       # The URL of the LDAP server
       url: ldap://<adminDN>:<adminPassword>@<host>:<port>/<base>
       # TLS configuration for the client connection to the LDAP server
       tls:
          certfiles:
          client:
             certfile:
             keyfile:
       # Attribute related configuration for mapping from LDAP entries to Fabric CA attributes
       attribute:
          # 'names' is an array of strings containing the LDAP attribute names which are
          # requested from the LDAP server for an LDAP identity's entry
          names: ['uid','member']
          # The 'converters' section is used to convert an LDAP entry to the value of
          # a fabric CA attribute.
          # For example, the following converts an LDAP 'uid' attribute
          # whose value begins with 'revoker' to a fabric CA attribute
          # named "hf.Revoker" with a value of "true" (because the boolean expression
          # evaluates to true).
          #    converters:
          #       - name: hf.Revoker
          #         value: attr("uid") =~ "revoker*"
          converters:
             - name:
               value:
          # The 'maps' section contains named maps which may be referenced by the 'map'
          # function in the 'converters' section to map LDAP responses to arbitrary values.
          # For example, assume a user has an LDAP attribute named 'member' which has multiple
          # values which are each a distinguished name (i.e. a DN). For simplicity, assume the
          # values of the 'member' attribute are 'dn1', 'dn2', and 'dn3'.
          # Further assume the following configuration.
          #    converters:
          #       - name: hf.Registrar.Roles
          #         value: map(attr("member"),"groups")
          #    maps:
          #       groups:
          #          - name: dn1
          #            value: peer
          #          - name: dn2
          #            value: client
          # The value of the user's 'hf.Registrar.Roles' attribute is then computed to be
          # "peer,client,dn3".  This is because the value of 'attr("member")' is
          # "dn1,dn2,dn3", and the call to 'map' with a 2nd argument of
          # "group" replaces "dn1" with "peer" and "dn2" with "client".
          maps:
             groups:
                - name:
                  value:
    #############################################################################
    # Affiliations section, specified as hierarchical maps.
    # Note: Affiliations are case sensitive except for the non-leaf affiliations.
    #############################################################################
    affiliations:
      substra:
      - paris
      - nantes
    #############################################################################
    #  Signing section
    #
    #  The "default" subsection is used to sign enrollment certificates;
    #  the default expiration ("expiry" field) is "8760h", which is 1 year in hours.
    #
    #  The "ca" profile subsection is used to sign intermediate CA certificates;
    #  the default expiration ("expiry" field) is "43800h" which is 5 years in hours.
    #  Note that "isca" is true, meaning that it issues a CA certificate.
    #  A maxpathlen of 0 means that the intermediate CA cannot issue other
    #  intermediate CA certificates, though it can still issue end entity certificates.
    #  (See RFC 5280, section 4.2.1.9)
    #
    #  The "tls" profile subsection is used to sign TLS certificate requests;
    #  the default expiration ("expiry" field) is "8760h", which is 1 year in hours.
    #############################################################################
    signing:
        default:
          usage:
            - digital signature
          expiry: 8760h
        profiles:
          ca:
             usage:
               - cert sign
               - crl sign
             expiry: 43800h
             caconstraint:
               isca: true
               maxpathlen: 0
          tls:
             usage:
                - signing
                - key encipherment
                - server auth
                - client auth
                - key agreement
             expiry: 8760h
    ###########################################################################
    #  Certificate Signing Request (CSR) section.
    #  This controls the creation of the root CA certificate.
    #  The expiration for the root CA certificate is configured with the
    #  "ca.expiry" field below, whose default value is "131400h" which is
    #  15 years in hours.
    #  The pathlength field is used to limit CA certificate hierarchy as described
    #  in section 4.2.1.9 of RFC 5280.
    #  Examples:
    #  1) No pathlength value means no limit is requested.
    #  2) pathlength == 1 means a limit of 1 is requested which is the default for
    #     a root CA.  This means the root CA can issue intermediate CA certificates,
    #     but these intermediate CAs may not in turn issue other CA certificates
    #     though they can still issue end entity certificates.
    #  3) pathlength == 0 means a limit of 0 is requested;
    #     this is the default for an intermediate CA, which means it can not issue
    #     CA certificates though it can still issue end entity certificates.
    ###########################################################################
    csr:
       cn: "rca"
       names:
          - C: "FR"
            ST: "Loire-Atlantique"
            L: "Nantes"
            O: "Substra"
            OU: 
       hosts:
         - localhost
         # K8S Service
         - my-release-hlf-ca.default.svc.cluster.local
       ca:
          expiry: 131400h
          pathlength: 1
    #############################################################################
    # BCCSP (BlockChain Crypto Service Provider) section is used to select which
    # crypto library implementation to use
    #############################################################################
    bccsp:
        default: SW
        sw:
            hash: SHA2
            security: 256
            filekeystore:
                # The directory used for the software file-based keystore
                keystore: msp/keystore
    #############################################################################
    # Multi CA section (unused in a K8S deployment)
    #############################################################################
    cacount:
    cafiles:
    #############################################################################
    # Intermediate CA section
    #
    # The relationship between servers and CAs is as follows:
    #   1) A single server process may contain or function as one or more CAs.
    #      This is configured by the "Multi CA section" above.
    #   2) Each CA is either a root CA or an intermediate CA.
    #   3) Each intermediate CA has a parent CA which is either a root CA or another intermediate CA.
    #
    # This section pertains to configuration of #2 and #3.
    # If the "intermediate.parentserver.url" property is set,
    # then this is an intermediate CA with the specified parent
    # CA.
    #
    # parentserver section
    #    url - The URL of the parent server
    #    caname - Name of the CA to enroll within the server
    #
    # enrollment section used to enroll intermediate CA with parent CA
    #    profile - Name of the signing profile to use in issuing the certificate
    #    label - Label to use in HSM operations
    #
    # tls section for secure socket connection
    #   certfiles - PEM-encoded list of trusted root certificate files
    #   client:
    #     certfile - PEM-encoded certificate file for when client authentication
    #     is enabled on server
    #     keyfile - PEM-encoded key file for when client authentication
    #     is enabled on server
    #############################################################################
    intermediate:
      parentserver:
        url:
        caname:
      enrollment:
        hosts:
        profile:
        label:
      tls:
        certfiles:
        client:
          certfile:
          keyfile:
    #############################################################################
    # Extra configuration options
    # .e.g to enable adding and removing affiliations or identities
    #############################################################################
    cfg:
      affiliations:
        allowremove: true
      identities:
        allowremove: true
---
# Source: hlf-k8s/charts/hlf-ca/templates/configmap--db.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-ca--db
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
data:
  DB_SSL: "disable"
---
# Source: hlf-k8s/charts/hlf-peer/templates/configmap--peer.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-peer--peer
  labels:
    app: hlf-peer
    heritage: "Helm"
    release: "my-release"
    chart: hlf-peer-5.1.0
data:
  CORE_PEER_ADDRESSAUTODETECT: "true"
  CORE_PEER_ID: my-release
  CORE_PEER_NETWORKID: nid1
  # If we have an ingress, we set hostname to it
  # Otherwise we use CORE_PEER_ADDRESSAUTODETECT to auto-detect its address
  CORE_PEER_LISTENADDRESS: 0.0.0.0:7051
  CORE_PEER_EVENTS_ADDRESS: 0.0.0.0:7053
  CORE_PEER_COMMITTER_ENABLED: "true"
  CORE_PEER_PROFILE_ENABLED: "true"
  CORE_PEER_DISCOVERY_PERIOD: 60s
  CORE_PEER_DISCOVERY_TOUCHPERIOD: 60s
  CORE_PEER_LOCALMSPID: "Org1MSP"
  CORE_PEER_MSPCONFIGPATH: /var/hyperledger/msp
  ###########
  # Logging #
  ###########
  FABRIC_LOGGING_SPEC: ""
  CORE_LOGGING_LEVEL: "info"
  CORE_LOGGING_PEER: "info"
  CORE_LOGGING_CAUTHDSL: "warning"
  CORE_LOGGING_GOSSIP: "info"
  CORE_LOGGING_LEDGER: "info"
  CORE_LOGGING_MSP: "warning"
  CORE_LOGGING_POLICIES: "warning"
  CORE_LOGGING_GRPC: "error"
  ##########
  # Gossip #
  ##########
  CORE_PEER_GOSSIP_BOOTSTRAP: "127.0.0.1:7051"
  CORE_PEER_GOSSIP_ENDPOINT: ""
  CORE_PEER_GOSSIP_EXTERNALENDPOINT: ""
  CORE_PEER_GOSSIP_ORGLEADER: "false"
  CORE_PEER_GOSSIP_USELEADERELECTION: "true"
  #############
  # CHAINCODE #
  #############
  CORE_CHAINCODE_BUILDER: "hyperledger/fabric-ccenv:2.4"
  CORE_CHAINCODE_GOLANG_RUNTIME: "hyperledger/fabric-baseos:2.4"
  ##########
  # TLS    #
  ##########
  CORE_PEER_TLS_ENABLED: "true"
  CORE_PEER_TLS_CERT_FILE: "/var/hyperledger/tls/server/pair/tls.crt"
  CORE_PEER_TLS_KEY_FILE: "/var/hyperledger/tls/server/pair/tls.key"
  CORE_PEER_TLS_ROOTCERT_FILE: "/var/hyperledger/tls/server/cert/cacert.pem"
  CORE_PEER_TLS_CLIENTAUTHREQUIRED: "true"
  # This is fixed prior to starting the peer
  CORE_PEER_TLS_CLIENTROOTCAS_FILES: "/var/hyperledger/tls/client/cert/*"
  CORE_PEER_TLS_CLIENTCERT_FILE: "/var/hyperledger/tls/client/pair/tls.crt"
  CORE_PEER_TLS_CLIENTKEY_FILE: "/var/hyperledger/tls/client/pair/tls.key"
  CORE_LEDGER_STATE_STATEDATABASE: "CouchDB"
  # Containers in the same pod share the host
  CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS: cdb-peer:5984
  PEER_CFG_PATH: /var/hyperledger/config
  FABRIC_CFG_PATH: /var/hyperledger/fabric_cfg
  GODEBUG: "netdns=go"
  ADMIN_MSP_PATH: /var/hyperledger/admin_msp
  ORD_TLS_PATH: /var/hyperledger/tls/ord/cert
##############
# Operations #
##############
###########
# Metrics #
###########
  CORE_METRICS_PROVIDER: "disabled"
---
# Source: hlf-k8s/templates/configmap-application-organization.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-k8s-application-organizations-mychannel
data:
  application-organizations: |
---
# Source: hlf-k8s/templates/configmap-application-proposal-organization.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-k8s-application-proposal-organizations-mychannel
data:
  application-proposal-organizations: |
---
# Source: hlf-k8s/templates/configmap-enrollment.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-k8s-enrollment
data:
  enrollments: |
---
# Source: hlf-k8s/templates/configmap-fabric.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-hlf-k8s-fabric
data:
  discoverConfig.yaml: |
    version: 0
    tlsconfig:
      certpath: /var/hyperledger/tls/client/pair/tls.crt
      keypath: /var/hyperledger/tls/client/pair/tls.key
      peercacertpath: /var/hyperledger/tls/server/cert/cacert.pem
      timeout: 0s
    signerconfig:
      mspid: MyOrganizationMSP
      identitypath: /var/hyperledger/msp/signcerts/cert.pem
      keypath: /var/hyperledger/msp/keystore/key.pem
  configtx.yaml: |
    Organizations:
    - &id001
      Name: MyOrganization
      ID: MyOrganizationMSP
      MSPDir: /var/hyperledger/admin_msp

      Policies: &id002
        Readers:
            Type: Signature
            Rule: "OR('MyOrganizationMSP.member')"
        Writers:
            Type: Signature
            Rule: "OR('MyOrganizationMSP.member')"
        Admins:
            Type: Signature
            Rule: "OR('MyOrganizationMSP.admin')"
        Endorsement:
            Type: Signature
            Rule: "OR('MyOrganizationMSP.member')"
      AnchorPeers:
      - Host: peer-hostname
        Port: 7051

    Capabilities:
      Channel: &ChannelCapabilities
          V2_0: true

      Orderer: &OrdererCapabilities
          V2_0: true

      Application: &ApplicationCapabilities
          V2_0: true

    Application: &ApplicationDefaults

      Organizations: null

      Policies: &ApplicationDefaultPolicies
        LifecycleEndorsement:
            Type: ImplicitMeta
            Rule: "ANY Endorsement"
        Endorsement:
            Type: ImplicitMeta
            Rule: "ANY Endorsement"
        Readers:
            Type: ImplicitMeta
            Rule: "ANY Readers"
        Writers:
            Type: ImplicitMeta
            Rule: "ANY Writers"
        Admins:
            Type: ImplicitMeta
            Rule: "ANY Admins"

      Capabilities:
          <<: *ApplicationCapabilities

    Profiles:
      OrgsChannel-mychannel:
        Capabilities:
          V2_0: true
        Policies:
            Readers:
                Type: ImplicitMeta
                Rule: "ANY Readers"
            Writers:
                Type: ImplicitMeta
                Rule: "ANY Writers"
            Admins:
                Type: ImplicitMeta
                Rule: "ANY Admins"
        Application:
          <<: *ApplicationDefaults
          Policies:
            LifecycleEndorsement:
                Type: ImplicitMeta
                Rule: "ANY Endorsement"
            Endorsement:
                Type: ImplicitMeta
                Rule: "MAJORITY Endorsement"
            Readers:
                Type: ImplicitMeta
                Rule: "ANY Readers"
            Writers:
                Type: ImplicitMeta
                Rule: "ANY Writers"
            Admins:
                Type: ImplicitMeta
                Rule: "MAJORITY Admins"
          Organizations:
          - *id001
        Consortium: SampleConsortium

  core.yaml: |
    chaincode:
      builder: hyperledger/fabric-ccenv:2.4
      golang:
          runtime: hyperledger/fabric-baseos:2.4
      externalBuilders:
        - name: external-builder
          path: /builders
    peer:
      BCCSP:
        Default: SW
        PKCS11:
          FileKeyStore:
            KeyStore: null
          Hash: null
          Label: null
          Library: null
          Pin: null
          Security: null
        SW:
          FileKeyStore:
            KeyStore: null
          Hash: SHA2
          Security: 256
      address: peer-hostname:7051
      addressAutoDetect: false
      adminService: null
      authentication:
        timewindow: 15m
      client:
        connTimeout: 3s
      deliveryclient:
        connTimeout: 3s
        reConnectBackoffThreshold: 3600s
        reconnectTotalTimeThreshold: 3600s
      discovery:
        authCacheEnabled: true
        authCacheMaxSize: 1000
        authCachePurgeRetentionRatio: 0.75
        enabled: true
        orgMembersAllowedAccess: false
      fileSystemPath: /var/hyperledger/production
      gomaxprocs: -1
      gossip:
        aliveExpirationTimeout: 25s
        aliveTimeInterval: 5s
        bootstrap: 127.0.0.1:7051
        connTimeout: 2s
        dialTimeout: 3s
        digestWaitTime: 1s
        election:
          leaderAliveThreshold: 10s
          leaderElectionDuration: 5s
          membershipSampleInterval: 1s
          startupGracePeriod: 15s
        endpoint: null
        externalEndpoint: peer-hostname:7051
        maxBlockCountToStore: 100
        maxPropagationBurstLatency: 10ms
        maxPropagationBurstSize: 10
        membershipTrackerInterval: 5s
        orgLeader: 'false'
        propagateIterations: 1
        propagatePeerNum: 3
        publishCertPeriod: 10s
        publishStateInfoInterval: 4s
        pullInterval: 4s
        pullPeerNum: 3
        pvtData:
          btlPullMargin: 10
          pullRetryThreshold: 60s
          pushAckTimeout: 3s
          reconcileBatchSize: 10
          reconcileSleepInterval: 1m
          reconciliationEnabled: true
          transientstoreMaxBlockRetention: 1000
        reconnectInterval: 25s
        recvBuffSize: 20
        requestStateInfoInterval: 4s
        requestWaitTime: 1500ms
        responseWaitTime: 2s
        sendBuffSize: 200
        skipBlockVerification: false
        skipHandshake: 'true'
        stateInfoRetentionInterval: null
        useLeaderElection: 'true'
      handlers:
        authFilters:
        - name: DefaultAuth
        - name: ExpirationCheck
        decorators:
        - name: DefaultDecorator
        endorsers:
          escc:
            library: null
            name: DefaultEndorsement
        validators:
          vscc:
            library: null
            name: DefaultValidation
      id: MyOrganization
      keepalive:
        client:
          interval: 60s
          timeout: 20s
        deliveryClient:
          interval: 60s
          timeout: 20s
        minInterval: 60s
      listenAddress: 0.0.0.0:7051
      localMspId: MyOrganizationMSP
      localMspType: bccsp
      mspConfigPath: /var/hyperledger/admin_msp
      networkId: dev
      profile:
        enabled: false
        listenAddress: 0.0.0.0:6060
      tls:
        enabled: 'true'
        cert:
          file: /var/hyperledger/tls/server/pair/tls.crt
        key:
          file: /var/hyperledger/tls/server/pair/tls.key
        clientAuthRequired: 'true'
        clientCert:
          file: /var/hyperledger/tls/client/pair/tls.crt
        clientKey:
          file: /var/hyperledger/tls/client/pair/tls.key
        clientRootCAs:
        - /var/hyperledger/admin_msp/cacerts/cacert.pem
        rootcert:
          file: /var/hyperledger/admin_msp/cacerts/cacert.pem
      validatorPoolSize: null
---
# Source: hlf-k8s/charts/hlf-ca/templates/pvc.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: my-release-hlf-ca
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "5Gi"
---
# Source: hlf-k8s/charts/hlf-peer/templates/pvc.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: my-release-hlf-peer
  labels:
    app: hlf-peer
    heritage: "Helm"
    release: "my-release"
    chart: hlf-peer-5.1.0
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "10Gi"
---
# Source: hlf-k8s/templates/rbac.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: my-release-hlf-k8s
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
    app.kubernetes.io/part-of: hlf-k8s
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs:
    - get
    - watch
    - list
    - create
    - delete
---
# Source: hlf-k8s/templates/rbac.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: my-release-hlf-k8s
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
    app.kubernetes.io/part-of: hlf-k8s
subjects:
- kind: ServiceAccount
  name: my-release-hlf-k8s
  namespace: default
roleRef:
  kind: Role
  name: my-release-hlf-k8s
  apiGroup: rbac.authorization.k8s.io
---
# Source: hlf-k8s/charts/couchdb/templates/headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-couchdb
  labels:
    app: couchdb
    chart: couchdb-3.3.4
    release: my-release
    heritage: Helm
spec:
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
    - name: couchdb
      port: 5984
  selector:
    app: couchdb
    release: my-release
---
# Source: hlf-k8s/charts/couchdb/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-svc-couchdb
  labels:
    app: couchdb
    chart: couchdb-3.3.4
    release: my-release
    heritage: Helm
spec:
  ports:
    - port: 5984
      protocol: TCP
      targetPort: 5984
  type: ClusterIP
  selector:
    app: couchdb
    release: my-release
---
# Source: hlf-k8s/charts/hlf-ca/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-hlf-ca
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
spec:
  type: "ClusterIP"
  ports:
    - port: 7054
      targetPort: 7054
      protocol: TCP
      name: http
  selector:
    app: hlf-ca
    release: my-release
---
# Source: hlf-k8s/charts/hlf-peer/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-hlf-peer
  labels:
    app: hlf-peer
    heritage: "Helm"
    release: "my-release"
    chart: hlf-peer-5.1.0
spec:
  type: ClusterIP
  ports:
    - port: 7051
      targetPort: 7051
      protocol: TCP
      name: request
    - port: 7053
      targetPort: 7053
      protocol: TCP
      name: event
  selector:
    app: hlf-peer
    release: my-release
---
# Source: hlf-k8s/templates/deployment-appchannel-operator.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-hlf-k8s-appchannel-operator-mychannel
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app.kubernetes.io/name: hlf-k8s-appchannel-operator-mychannel
    app.kubernetes.io/instance: my-release
---
# Source: hlf-k8s/templates/deployment-config-operator.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-hlf-k8s-config-operator
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app.kubernetes.io/name: hlf-k8s-config-operator
    app.kubernetes.io/instance: my-release
---
# Source: hlf-k8s/charts/hlf-ca/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-hlf-ca
  labels:
    app: hlf-ca
    heritage: "Helm"
    release: "my-release"
    chart: hlf-ca-2.1.0
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hlf-ca
      release: my-release
  # Ensure we allow our pod to be unavailable, so we can upgrade
  strategy:
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: hlf-ca
        heritage: "Helm"
        release: "my-release"
        chart: hlf-ca-2.1.0
    spec:
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: my-release-hlf-ca
        - name: ca-config
          configMap:
            name: my-release-hlf-ca--config
      initContainers:
        - name: wait-for-db
          image: "jwilder/dockerize:latest"
          imagePullPolicy: IfNotPresent
          envFrom:
            - configMapRef:
                name: my-release-hlf-ca--db
          command:
            - sh
            - -c
            - |
              if [ -n "$DB_TYPE" ]; then
                dockerize -wait tcp://$DB_HOST:$DB_PORT -timeout 30s && echo "Database $DB_TYPE on $DB_HOST:$DB_PORT is ready"
              fi
      containers:
        - name: ca
          image: "hyperledger/fabric-ca:1.5.0"
          imagePullPolicy: IfNotPresent
          command:
            - sh
            - -c
            - |
              if [ -n "$DB_TYPE" ]; then
                while [ -z ${DB_PASSWORD+x} ];
                do
                  echo "\033[0;31mDB_PASSWORD environmental variable must contain a value \033[0m"
                  sleep 60
                done

                case "$DB_TYPE" in
                  postgres)
                    export DB_DATASOURCE="host=${DB_HOST} port=${DB_PORT} user=${DB_USERNAME} password=${DB_PASSWORD} dbname=${DB_DATABASE} sslmode=${DB_SSL}";;
                  mysql)
                    export DB_DATASOURCE="${DB_USERNAME}:${DB_PASSWORD}@tcp(${DB_HOST}:${DB_PORT})/${DB_DATABASE}?parseTime=true" ;;
                  *)
                    echo "\033[0;31m Database type '$DB_TYPE' not supported\033[0m"; exit 1;;
                esac
              fi

              mkdir -p $FABRIC_CA_HOME
              cp /var/hyperledger/ca_config/ca.yaml $FABRIC_CA_HOME/fabric-ca-server-config.yaml
              sed -i "s|<<<ADMIN>>>|${CA_ADMIN}|g" ${FABRIC_CA_HOME}/fabric-ca-server-config.yaml
              sed -i "s|<<<ADMINPW>>>|${CA_PASSWORD}|g" $FABRIC_CA_HOME/fabric-ca-server-config.yaml
              sed -i "s|<<<DB_TYPE>>>|${DB_TYPE:-"sqlite3"}|g" $FABRIC_CA_HOME/fabric-ca-server-config.yaml
              sed -i "s|<<<DB_DATASOURCE>>>|${DB_DATASOURCE:-"fabric-ca-server.db"}|g" $FABRIC_CA_HOME/fabric-ca-server-config.yaml

              echo ">\033[0;35m fabric-ca-server start \033[0m"
              fabric-ca-server start
          envFrom:
            - secretRef:
                name: my-release-hlf-ca--ca
            - configMapRef:
                name: my-release-hlf-ca--db
            - configMapRef:
                name: my-release-hlf-ca--ca
          env:
          ports:
            - name: ca-port
              containerPort: 7054
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /cainfo
              port: 7054
          readinessProbe:
            httpGet:
              path: /cainfo
              port: 7054
          volumeMounts:
            - name: data
              mountPath: /var/hyperledger
            - name: ca-config
              readOnly: true
              mountPath: /var/hyperledger/ca_config
          resources:
            {}
---
# Source: hlf-k8s/charts/hlf-peer/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-hlf-peer
  labels:
    app: hlf-peer
    heritage: "Helm"
    release: "my-release"
    chart: hlf-peer-5.1.0
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hlf-peer
      release: my-release
  # Ensure we allow our pod to be unavailable, so we can upgrade
  strategy:
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: hlf-peer
        heritage: "Helm"
        release: "my-release"
        chart: hlf-peer-5.1.0
    spec:
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: my-release-hlf-peer
        - name: id-cert
          secret:
            secretName: hlf-msp-cert-user
        - name: id-key
          secret:
            secretName: hlf-msp-key-user
        - name: cacert
          secret:
            secretName: hlf-cacert
        - name: tls
          secret:
            secretName: hlf-tls-admin
        - name: tls-rootcert
          secret:
            secretName: hlf-cacert
        - name: tls-client
          secret:
            secretName: hlf-tls-user
        - name: tls-clientrootcert
          secret:
            secretName: hlf-cacert
        - name: admin-cert
          secret:
            secretName: hlf-msp-cert-admin
        - name: admin-key
          secret:
            secretName: hlf-msp-key-admin
        - name: ord-tls-rootcert
          secret:
            secretName: ord-tls-rootcert
      containers:
        - name: peer
          image: "ghcr.io/substra/fabric-peer:0.2.4"
          imagePullPolicy: IfNotPresent
          ports:
            - name: request
              containerPort: 7051
              protocol: TCP
            - name: event
              containerPort: 7053
              protocol: TCP
          livenessProbe:
            exec:
              command:
              - ls
              - /var/hyperledger
            initialDelaySeconds: 5
            periodSeconds: 5
          # TODO: Improve readiness probe (ideally `ps aux | awk '$11=="orderer"'`)
          readinessProbe:
            exec:
              command:
              - ls
              - /var/hyperledger
            initialDelaySeconds: 15
          command:
            - sh
            - -c
            - |
              # To avoid having separate secrets for CouchDB and HLF
              export CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=$COUCHDB_USER
              export CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=$COUCHDB_PASSWORD

              while [ ! -d /var/hyperledger/admin_msp/admincerts ] || [ -z "$(ls -A /var/hyperledger/admin_msp/admincerts)" ];
              do
                echo "\033[0;31m /var/hyperledger/admin_msp/admincerts must contain Peer admin certificates files \033[0m"
                sleep 60
              done

              while [ ! -d ${CORE_PEER_MSPCONFIGPATH}/signcerts ];
              do
                echo "\033[0;31m ${CORE_PEER_MSPCONFIGPATH}/signcerts directory must exist \033[0m"
                sleep 60
              done

              if [ ! -d ${FABRIC_CFG_PATH} ]
              then
                mkdir -p ${FABRIC_CFG_PATH}
                cp -r /etc/hyperledger/fabric/core.yaml ${FABRIC_CFG_PATH}
                ls ${FABRIC_CFG_PATH}
              fi

              if [ $CORE_PEER_TLS_CLIENTAUTHREQUIRED ]
              then
                export CORE_PEER_TLS_CLIENTROOTCAS_FILES=$(ls -d $CORE_PEER_TLS_CLIENTROOTCAS_FILES)
              fi

              echo ">\033[0;35m peer node start \033[0m"
              peer node start
          envFrom:
            - secretRef:
                name: hlf-couchdb-credentials
            - configMapRef:
                name: my-release-hlf-peer--peer
          volumeMounts:
            - mountPath: /var/hyperledger
              name: data
            - mountPath: /var/hyperledger/msp/signcerts
              name: id-cert
            - mountPath: /var/hyperledger/msp/keystore
              name: id-key
            - mountPath: /var/hyperledger/msp/cacerts
              name: cacert
            - mountPath: /var/hyperledger/admin_msp/cacerts
              name: cacert
            - mountPath: /var/hyperledger/tls/server/pair
              name: tls
            - mountPath: /var/hyperledger/tls/server/cert
              name: tls-rootcert
            - mountPath: /var/hyperledger/tls/client/pair
              name: tls-client
            - mountPath: /var/hyperledger/tls/client/cert
              name: tls-clientrootcert
            - mountPath: /var/hyperledger/tls/ord/cert
              name: ord-tls-rootcert
            - mountPath: /var/hyperledger/admin_msp/admincerts
              name: admin-cert
            - mountPath: /var/hyperledger/admin_msp/signcerts
              name: admin-cert
            - mountPath: /var/hyperledger/msp/admincerts
              name: admin-cert
            - mountPath: /var/hyperledger/admin_msp/keystore
              name: admin-key
          resources:
            {}
---
# Source: hlf-k8s/templates/deployment-appchannel-operator.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-hlf-k8s-appchannel-operator-mychannel
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
spec:
  replicas: 1
  selector:
    matchLabels:
        app.kubernetes.io/name: hlf-k8s-appchannel-operator-mychannel
        app.kubernetes.io/instance: my-release
  template:
    metadata:
      labels:
        app.kubernetes.io/name: hlf-k8s-appchannel-operator-mychannel
        app.kubernetes.io/instance: my-release
    spec:
      serviceAccountName: my-release-hlf-k8s
      containers:
      - name: fabric-tools
        image: ghcr.io/substra/fabric-tools:0.2.4
        imagePullPolicy: "IfNotPresent"
        command: ['sh', '-c']
        args:
          - |
            ## Update CA certs
            update-ca-certificates

            ## Check connection with the Orderer
            printf "[DEBUG] Testing the connection with the Orderer (orderer-hostname:7050)\n"
            until $(nc -z orderer-hostname 7050); do
              printf "[DEBUG] Orderer (orderer-hostname:7050) is not reacheable, retry in 5s\n"
              sleep 5
            done

            ## Add orgs to the application channel
            while true; do

              ## Create and join application channel
              until grep -e "existing.*mychannel" -e "FORBIDDEN" channel.created > /dev/null; do

                printf "[DEBUG] Create and join the application channel (mychannel)\n"

                ## Create channel
                configtxgen -profile OrgsChannel-mychannel --outputCreateChannelTx channel.tx -channelID mychannel -asOrg MyOrganization
                peer channel create -f channel.tx \
                  --outputBlock channel.block \
                  -c mychannel \
                  --tls \
                  --clientauth \
                  --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                  --keyfile /var/hyperledger/tls/client/pair/tls.key \
                  --certfile /var/hyperledger/tls/client/pair/tls.crt \
                  -o orderer-hostname:7050 2> channel.created

                ## Create and add anchor
                configtxgen -profile OrgsChannel-mychannel --outputAnchorPeersUpdate anchor.tx -channelID mychannel -asOrg MyOrganization

                peer channel update \
                  -f anchor.tx \
                  -c mychannel \
                  --tls \
                  --clientauth \
                  --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                  --keyfile /var/hyperledger/tls/client/pair/tls.key \
                  --certfile /var/hyperledger/tls/client/pair/tls.crt \
                  -o orderer-hostname:7050

                sleep 1
              done

              ## Join Application Channel
              ## Fetch channel list

              peer channel list \
                --tls \
                --clientauth \
                --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                --keyfile /var/hyperledger/tls/client/pair/tls.key \
                --certfile /var/hyperledger/tls/client/pair/tls.crt \
                -o orderer-hostname:7050 > channel.list

              until grep "^mychannel$" channel.list > /dev/null; do

                printf "[DEBUG] Fetching application channel block\n"
                peer channel fetch oldest channeljoin.block \
                  -c mychannel \
                  --tls \
                  --clientauth \
                  --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                  --keyfile /var/hyperledger/tls/client/pair/tls.key \
                  --certfile /var/hyperledger/tls/client/pair/tls.crt \
                  -o orderer-hostname:7050

                printf "[DEBUG] Joining channel\n"
                peer channel join -b channeljoin.block

                ## Fetch channel list
                peer channel list \
                  --tls \
                  --clientauth \
                  --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                  --keyfile /var/hyperledger/tls/client/pair/tls.key \
                  --certfile /var/hyperledger/tls/client/pair/tls.crt \
                  -o orderer-hostname:7050 > channel.list

                sleep 1
              done


              ## Add organizations to application channel

              while IFS=" " read -r org mspid configUrl ; do

                ## Delete stale channel configuration files
                rm -rf \
                  channel.block \
                  channel-cfg.block \
                  channel-cfg.json


                ## Fetch up-to-date channel configuration block
                until [ -f "channel.block" ] && [ -s "channel.block" ]; do
                  printf "[DEBUG] Fetching the channel (mychannel) configuration block\n"
                  peer channel fetch config channel.block \
                    -c mychannel \
                    --tls \
                    --clientauth \
                    --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                    --keyfile /var/hyperledger/tls/client/pair/tls.key \
                    --certfile /var/hyperledger/tls/client/pair/tls.crt \
                    -o orderer-hostname:7050 > /tmp/out.txt 2>&1 || cat /tmp/out.txt
                  sleep 3
                done

                ## Check if update has been already sent
                printf "[DEBUG] Check if $org is in the application channel \n"
                configtxlator proto_decode --input channel.block --type common.Block | jq .data.data[0].payload.data.config > channel-$org-hasjoined.json
                if grep "$mspid" channel-$org-hasjoined.json > /dev/null; then
                  printf "[DEBUG] $org is already in the application channel\n"
                  rm -f /data/proposal-$org.pb
                  sleep 5
                  continue
                else
                  printf "[DEBUG] $org is not in the application channel\n"
                  ## Remove all configuration files because of edge cases (network issue, proposal issue).
                  ## We prefer to delete all and retry all steps to avoid side effect.
                  rm -f *-$org.*
                fi

                ## Fetch organization configuration
                if ! [ -s "configOrg-$org.json" ]; then
                  printf "[DEBUG] Fetch the organization ($org) configuration from $configUrl\n"
                  curl --fail -L --output ./configOrg-$org.json $configUrl || continue # continue to next org if curl fails
                fi

                ## Extract application channel configuration
                until [ -f "channel-cfg.block" ] && [ -s "channel-cfg.block" ]; do
                  configtxlator proto_decode --input channel.block --type common.Block | jq .data.data[0].payload.data.config > channel-cfg.json
                  configtxlator proto_encode --input channel-cfg.json --type common.Config --output channel-cfg.block
                  sleep 2
                done


                ## Fetch update proposal from external orgs if exists
                while IFS=" " read -r orgProposal mspidProposal proposalServerUrl ; do

                  # Don't need to network-fetch proposals made by ourselves
                  if [ "$orgProposal" = "MyOrganization" ]; then continue; fi

                  printf "[DEBUG] Fetch the update proposal built by organization ($orgProposal) for organization ($org) from $proposalServerUrl/proposal-$org.pb \n"
                  curl --fail -L --output ./external-$orgProposal-proposal-$org.pb $proposalServerUrl/proposal-$org.pb

                  ## Compare external proposal file with local one, keep the largest (more signatures) between them as the only difference will be the number of signatures
                  if [ -s "external-$orgProposal-proposal-$org.pb" ]
                  then
                    if [ -s "proposal-$org.pb" ] ; then
                      if [ $(stat -c %s "external-$orgProposal-proposal-$org.pb") -gt $(stat -c %s "proposal-$org.pb") ] ; then
                        printf "[DEBUG] Use the $org update proposal from $orgProposal as there are more signatures in it !\n"
                        cp external-$orgProposal-proposal-$org.pb proposal-$org.pb
                      fi
                    else
                      printf "[DEBUG] Use the $org update proposal from $orgProposal \n"
                      cp external-$orgProposal-proposal-$org.pb proposal-$org.pb
                    fi
                  fi

                done < /proposal/application-proposal-organizations

                ## Create proposal if not fetched
                until [ -f "proposal-$org.pb" ]; do
                  printf "[DEBUG] Create application channel update for $org \n"

                  ## Add the Organization in the Applciation group
                  jq -s '.[0] * {"channel_group":{"groups":{"Application":{"groups":{"'$org'":.[1]}}}}}' channel-cfg.json configOrg-$org.json > new-channel-cfg-$org.json
                  configtxlator proto_encode --input new-channel-cfg-$org.json --type common.Config --output channelupdate-$org.block

                  ## Compute update between channel old configuration and the updated one
                  configtxlator compute_update \
                    --channel_id mychannel \
                    --original channel-cfg.block \
                    --updated channelupdate-$org.block \
                    | configtxlator proto_decode --type common.ConfigUpdate | jq . > compute_update-$org.json

                  ## Create the update proposal
                  echo '{"payload":{"header":{"channel_header":{"channel_id": "mychannel", "type":2}},"data":{"config_update":'$(cat compute_update-$org.json)'}}}' | jq . > proposal-$org.json
                  configtxlator proto_encode --input proposal-$org.json --type common.Envelope --output proposal-$org.pb

                  sleep 2
                done

                ## Validate proposal application version
                PROPOSAL_APP_VERSION=$(cat channel-cfg.json | jq '.channel_group.groups.Application.version')
                CHANNEL_APP_VERSION=$(configtxlator proto_decode --input proposal-$org.pb --type common.Envelope | jq '.payload.data.config_update.read_set.groups.Application.version')
                printf "[DEBUG] Proposal application version: $CHANNEL_APP_VERSION. Channel application version: $PROPOSAL_APP_VERSION\n"
                if [ $CHANNEL_APP_VERSION != $PROPOSAL_APP_VERSION ] ; then
                  # Proposal update should have a readset application version matching config application version.
                  # That suggests the proposal update is not up to date with the latest ledger state.
                  printf "[DEBUG] Application version mismatch. Delete proposal for '$org'.\n"
                  rm -f /data/proposal-$org.pb proposal-$org.pb
                  continue
                fi

                ## Sign update proposal
                peer channel signconfigtx \
                  -f proposal-$org.pb \
                  --tls \
                  --clientauth \
                  --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                  --keyfile /var/hyperledger/tls/client/pair/tls.key \
                  --certfile /var/hyperledger/tls/client/pair/tls.crt \
                  -o orderer-hostname:7050

                ## Update proposal in /data
                cp proposal-$org.pb /data/proposal-$org.pb
                chmod +r /data/proposal-$org.pb

                ## Submit proposal
                NUM_SIGNATURES=$(configtxlator proto_decode --input proposal-$org.pb --type common.Envelope | jq '.payload.data.signatures | map(.signature_header.creator.mspid) | unique | length')
                NUM_APPLICATION_ORGS=$(wc -l /proposal/application-proposal-organizations | cut -c 1)
                printf "[DEBUG] Submit channel update for '$org' with $NUM_SIGNATURES signatures (out of $NUM_APPLICATION_ORGS organizations)\n"
                peer channel update \
                  -f proposal-$org.pb \
                  -c mychannel \
                  --tls \
                  --clientauth \
                  --cafile /var/hyperledger/tls/ord/cert/cacert.pem \
                  --keyfile /var/hyperledger/tls/client/pair/tls.key \
                  --certfile /var/hyperledger/tls/client/pair/tls.crt \
                  -o orderer-hostname:7050

                sleep 1

              done < /config/application-organizations
              sleep 10
            done
        resources:
              null
        env:
        - name: CORE_PEER_MSPCONFIGPATH
          value: /var/hyperledger/admin_msp
        - name: GODEBUG
          value: "netdns=go+1"
        volumeMounts:
          - mountPath: /etc/hyperledger/fabric
            name: fabric-config
            readOnly: true
          - mountPath: /config
            name: application-organizations
            readOnly: true
          - mountPath: /proposal
            name: application-proposal-organizations
            readOnly: true
          - mountPath: /var/hyperledger/msp/signcerts
            name: id-cert
          - mountPath: /var/hyperledger/msp/keystore
            name: id-key
          - mountPath: /var/hyperledger/msp/cacerts
            name: cacert
          - mountPath: /var/hyperledger/msp/tlscacerts
            name: cacert
          - mountPath: /var/hyperledger/msp/admincerts
            name: admin-cert
          - mountPath: /var/hyperledger/tls/server/pair
            name: tls
          - mountPath: /var/hyperledger/tls/server/cert
            name: tls-rootcert
          - mountPath: /var/hyperledger/tls/client/pair
            name: tls-client
          - mountPath: /var/hyperledger/tls/client/cert
            name: tls-clientrootcert
          - mountPath: /var/hyperledger/tls/ord/cert
            name: ord-tls-rootcert
          - mountPath: /var/hyperledger/admin_msp/signcerts
            name: admin-cert
          - mountPath: /var/hyperledger/admin_msp/keystore
            name: admin-key
          - mountPath: /var/hyperledger/admin_msp/cacerts
            name: cacert
          - mountPath: /var/hyperledger/admin_msp/tlscacerts
            name: cacert
          - mountPath: /var/hyperledger/admin_msp/admincerts
            name: admin-cert
          - mountPath: /data
            name: data
      - name: nginx
        image: nginx:1.17.6
        ports:
        - containerPort: 80
        volumeMounts:
          - mountPath: /usr/share/nginx/html/proposal
            name: data
      volumes:
        - name: application-organizations
          configMap:
            name: my-release-hlf-k8s-application-organizations-mychannel
        - name: application-proposal-organizations
          configMap:
            name: my-release-hlf-k8s-application-proposal-organizations-mychannel
        - name: fabric-config
          configMap:
            name: my-release-hlf-k8s-fabric
        - name: id-cert
          secret:
            secretName: hlf-msp-cert-user
        - name: id-key
          secret:
            secretName: hlf-msp-key-user
        - name: cacert
          secret:
            secretName: hlf-cacert
        - name: tls
          secret:
            secretName: hlf-tls-admin
        - name: tls-rootcert
          secret:
            secretName: hlf-cacert
        - name: tls-client
          secret:
            secretName: hlf-tls-user
        - name: tls-clientrootcert
          secret:
            secretName: hlf-cacert
        - name: admin-cert
          secret:
            secretName: hlf-msp-cert-admin
        - name: admin-key
          secret:
            secretName: hlf-msp-key-admin
        - name: ord-tls-rootcert
          secret:
            secretName: ord-tls-rootcert
        - name: data
          emptyDir: {}
---
# Source: hlf-k8s/templates/deployment-config-operator.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-hlf-k8s-config-operator
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
spec:
  replicas: 1
  selector:
    matchLabels:
        app.kubernetes.io/name: hlf-k8s-config-operator
        app.kubernetes.io/instance: my-release
  template:
    metadata:
      labels:
        app.kubernetes.io/name: hlf-k8s-config-operator
        app.kubernetes.io/instance: my-release
    spec:
      serviceAccountName: my-release-hlf-k8s
      containers:
        - name: fabric-tools
          image: ghcr.io/substra/fabric-tools:0.2.4
          imagePullPolicy: "IfNotPresent"
          command: ['sh', '-c']
          args:
            - |
              ## Create configuration files (public keys) for the organization
              while true; do

                until [ -f "/data/configOrg.json" ]; do
                  printf "[DEBUG] Create the organization config file\n"
                  configtxgen -printOrg MyOrganization > /data/configOrg.json
                  sleep 1
                done

                until [ -f "/data/configOrgWithAnchors.json" ]; do
                  printf "[DEBUG] Create the org config anchor file\n"
                  jq -s '.[0] * {"values":{"AnchorPeers":{"mod_policy":"Admins", "value":{"anchor_peers":[{"host":"peer-hostname", "port":"7051"}]}, "version": "0"}}}' /data/configOrg.json > /data/configOrgWithAnchors.json
                  sleep 1
                done

                sleep 10
              done
          resources:
              null
          env:
          - name: CORE_PEER_MSPCONFIGPATH
            value: /var/hyperledger/admin_msp
          - name: GODEBUG
            value: "netdns=go+1"
          volumeMounts:
            - mountPath: /etc/hyperledger/fabric
              name: fabric-config
              readOnly: true
            - mountPath: /var/hyperledger/msp/signcerts
              name: id-cert
            - mountPath: /var/hyperledger/msp/keystore
              name: id-key
            - mountPath: /var/hyperledger/msp/cacerts
              name: cacert
            - mountPath: /var/hyperledger/msp/tlscacerts
              name: cacert
            - mountPath: /var/hyperledger/msp/admincerts
              name: admin-cert
            - mountPath: /var/hyperledger/tls/server/pair
              name: tls
            - mountPath: /var/hyperledger/tls/server/cert
              name: tls-rootcert
            - mountPath: /var/hyperledger/tls/client/pair
              name: tls-client
            - mountPath: /var/hyperledger/tls/client/cert
              name: tls-clientrootcert
            - mountPath: /var/hyperledger/tls/ord/cert
              name: ord-tls-rootcert
            - mountPath: /var/hyperledger/admin_msp/signcerts
              name: admin-cert
            - mountPath: /var/hyperledger/admin_msp/keystore
              name: admin-key
            - mountPath: /var/hyperledger/admin_msp/cacerts
              name: cacert
            - mountPath: /var/hyperledger/admin_msp/tlscacerts
              name: cacert
            - mountPath: /var/hyperledger/admin_msp/admincerts
              name: admin-cert
            - mountPath: /data
              name: data
        - name: nginx
          image: nginx:1.17.6
          ports:
          - containerPort: 80
          volumeMounts:
            - mountPath: /usr/share/nginx/html/config
              name: data
      volumes:
        - name: fabric-config
          configMap:
            name: my-release-hlf-k8s-fabric
        - name: id-cert
          secret:
            secretName: hlf-msp-cert-user
        - name: id-key
          secret:
            secretName: hlf-msp-key-user
        - name: cacert
          secret:
            secretName: hlf-cacert
        - name: tls
          secret:
            secretName: hlf-tls-admin
        - name: tls-rootcert
          secret:
            secretName: hlf-cacert
        - name: tls-client
          secret:
            secretName: hlf-tls-user
        - name: tls-clientrootcert
          secret:
            secretName: hlf-cacert
        - name: admin-cert
          secret:
            secretName: hlf-msp-cert-admin
        - name: admin-key
          secret:
            secretName: hlf-msp-key-admin
        - name: ord-tls-rootcert
          secret:
            secretName: ord-tls-rootcert
        - name: data
          emptyDir: {}
---
# Source: hlf-k8s/templates/deployment-enrollement-operator.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-hlf-k8s-enrollment-operator
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s
spec:
  replicas: 1
  selector:
    matchLabels:
        app.kubernetes.io/name: hlf-k8s-enrollment-operator
        app.kubernetes.io/instance: my-release
  template:
    metadata:
      labels:
        app.kubernetes.io/name: hlf-k8s-enrollment-operator
        app.kubernetes.io/instance: my-release
    spec:
      serviceAccountName: my-release-hlf-k8s
      containers:
        - name: fabric-tools
          image: ghcr.io/substra/fabric-tools:0.2.4
          imagePullPolicy: "IfNotPresent"
          command: ['sh', '-c']
          args:
            - |
              ## Update CA certs
              update-ca-certificates

              ## Check connection with the Certificate Authority
              printf "[DEBUG] Testing the connection with this node's Certificate Authority (http://ca-hostname:7054)\n"
              until fabric-ca-client getcainfo -u http://ca-hostname:7054; do
                printf "[DEBUG] Certificate Authority (http://ca-hostname:7054) server is not reacheable, retry in 5s\n"
                sleep 5
              done

              ## Enroll CA administrator
              printf "[DEBUG] Testing enrollment of CA admin\n"
              until fabric-ca-client identity list -u http://caAdmin:caPassword@ca-hostname:7054 --id caAdmin; do
                printf "[DEBUG] Certificate Authority admin is not enrolled, enrolling it now:\n"
                fabric-ca-client enroll -d -u http://caAdmin:caPassword@ca-hostname:7054 -M /var/hyperledger/fabric-ca/msp
                sleep 1
              done

              ## Create CA cert kubernetes secret
              ## Note: The CA cert is shared between all identities (CA admin, admins, and users)
              until kubectl get secret hlf-cacert > /dev/null; do
                printf "[DEBUG] CA cacerts k8s secret not found, creating it now:\n"
                kubectl create secret generic hlf-cacert --from-file=cacert.pem=$(find /var/hyperledger/fabric-ca/msp/cacerts -type f)
                sleep 1
              done

              ## Check connection with the Orderer Certificate Authority
              printf "[DEBUG] Testing the connection with the Orderer Certificate Authority (http://orderer-ca-hostname:7054)\n"
              until fabric-ca-client getcainfo -u http://orderer-ca-hostname:7054 -H /tmp/orderer; do
                printf "[DEBUG] Orderer Certificate Authority (http://orderer-ca-hostname:7054) server is not reacheable, retry in 5s\n"
                sleep 5
              done

              ## Create Orderer CA Cert kubernetes secret
              until kubectl get secret ord-tls-rootcert > /dev/null; do
                printf "[DEBUG] Orderer CA cacerts k8s secret not found, creating it now:\n"
                kubectl create secret generic ord-tls-rootcert --from-file=cacert.pem=$(find /tmp/orderer/msp/cacerts -type f)
                sleep 1
              done

              ## Enroll users
              while true; do

                while IFS=" " read -r name secret options; do

                  printf "[DEBUG] Checking enrollment of CA user $name\n"

                  ## Register user
                  until fabric-ca-client identity list -u http://caAdmin:caPassword@ca-hostname:7054 --id $name; do
                    printf "[DEBUG] User $name is not registered, registering the user now:\n"
                    fabric-ca-client register -d -u http://caAdmin:caPassword@ca-hostname:7054 --id.name $name --id.secret $secret $options
                    sleep 1
                  done

                  ## Enroll user (MSP)
                  until [ -d "/data/$name/msp" ]; do
                    printf "[DEBUG] MSP certificate not found: enrolling user '$name' now:\n"
                    fabric-ca-client enroll -d -u http://$name:$secret@ca-hostname:7054 -M /data/$name/msp
                    sleep 1
                  done

                  ## Enroll user (TLS)
                  until [ -d "/data/$name/tls" ]; do
                    printf "[DEBUG] TLS certificate not found: enrolling user '$name' with TLS profile now:\n"
                    fabric-ca-client enroll -d --enrollment.profile tls -u http://$name:$secret@ca-hostname:7054 -M /data/$name/tls --csr.hosts "localhost,127.0.0.1,service-hostname"
                    sleep 1
                  done

                  ## Create secret: MSP cert
                  until kubectl get secret hlf-msp-cert-$name > /dev/null; do
                    printf "[DEBUG] User '$name' 'MSP cert' secret not found, creating it now:\n"
                    kubectl create secret generic hlf-msp-cert-$name --from-file=cert.pem=/data/$name/msp/signcerts/cert.pem
                    sleep 1
                  done

                  ## Create secret: MSP key
                  until kubectl get secret hlf-msp-key-$name > /dev/null; do
                    printf "[DEBUG] User '$name' 'MSP key' secret not found, creating it now:\n"
                    kubectl create secret generic hlf-msp-key-$name --from-file=key.pem=$(find /data/$name/msp/keystore -type f)
                    sleep 1
                  done

                  ## Create secret: TLS pair
                  until kubectl get secret hlf-tls-$name > /dev/null; do
                    printf "[DEBUG] User '$name' 'TLS pair' secret not found, creating it now:\n"
                    kubectl create secret tls hlf-tls-$name --key $(find /data/$name/tls/keystore -type f) --cert /data/$name/tls/signcerts/cert.pem
                    sleep 1
                  done

                done < /config/enrollments

                sleep 10
              done
          resources:
              null
          volumeMounts:
            - mountPath: /etc/hyperledger/fabric
              name: fabric-config
              readOnly: true
            - mountPath: /config
              name: enrollment
              readOnly: true
            - mountPath: /data
              name: data
      volumes:
        - name: fabric-config
          configMap:
            name: my-release-hlf-k8s-fabric
        - name: enrollment
          configMap:
            name: my-release-hlf-k8s-enrollment
        - name: data
          emptyDir: {}
---
# Source: hlf-k8s/charts/couchdb/templates/statefulset.yaml
apiVersion:  apps/v1
kind: StatefulSet
metadata:
  name: my-release-couchdb
  labels:
    app: couchdb
    chart: couchdb-3.3.4
    release: my-release
    heritage: Helm
spec:
  replicas: 1
  serviceName: my-release-couchdb
  podManagementPolicy: Parallel
  selector:
    matchLabels:
      app: couchdb
      release: my-release
  template:
    metadata:
      labels:
        app: couchdb
        release: my-release
    spec:
      serviceAccountName: my-release-couchdb
      initContainers:
        - name: init-copy
          image: "busybox:latest"
          imagePullPolicy: Always
          command: ['sh','-c','cp /tmp/chart.ini /default.d; cp /tmp/seedlist.ini /default.d; ls -lrt /default.d;']
          volumeMounts:
          - name: config
            mountPath: /tmp/
          - name: config-storage
            mountPath: /default.d
      containers:
        - name: couchdb
          image: "couchdb:3.1.1"
          imagePullPolicy: IfNotPresent
          ports:
            - name: couchdb
              containerPort: 5984
            - name: epmd
              containerPort: 4369
            - containerPort: 9100
          env:
            - name: COUCHDB_USER
              valueFrom:
                secretKeyRef:
                  name: my-release-couchdb
                  key: adminUsername
            - name: COUCHDB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-release-couchdb
                  key: adminPassword
            - name: COUCHDB_SECRET
              valueFrom:
                secretKeyRef:
                  name: my-release-couchdb
                  key: cookieAuthSecret
            - name: ERL_FLAGS
              value: " -name couchdb  -setcookie monster "
          livenessProbe:
            httpGet:
              path: /_up
              port: 5984
            failureThreshold: 3
            initialDelaySeconds: 0
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          readinessProbe:
            httpGet:
              path: /_up
              port: 5984
            failureThreshold: 3
            initialDelaySeconds: 0
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            {}
          volumeMounts:
          - name: config-storage
            mountPath: /opt/couchdb/etc/default.d
          - name: database-storage
            mountPath: /opt/couchdb/data
      volumes:
        - name: config-storage
          emptyDir: {}
        - name: config
          configMap:
            name: my-release-couchdb
            items:
              - key: inifile
                path: chart.ini
              - key: seedlistinifile
                path: seedlist.ini
  volumeClaimTemplates:
    - metadata:
        name: database-storage
        labels:
          app: couchdb
          release: my-release
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "10Gi"
---
# Source: hlf-k8s/templates/configmap-application-organization.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/configmap-application-proposal-organization.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/configmap-system-organizations.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/deployment-appchannel-operator.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/deployment-chaincode-operator.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/deployment-genesis-operator.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/deployment-monitor.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/deployment-system-channel-operator.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/deployment-toolbox.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/rbac.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---
# Source: hlf-k8s/templates/job-hook-delete-secrets.yaml
# Copyright 2018 Owkin, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
apiVersion: batch/v1
kind: Job
metadata:
  name: my-release-hlf-k8s-hook-delete-secrets
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s-hook-delete-secrets
    app.kubernetes.io/part-of: hlf-k8s
  annotations:
    "helm.sh/hook": post-delete
    "helm.sh/hook-delete-policy": hook-succeeded
  namespace: "default"
spec:
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: 
      containers:
      - name: fabric-tools
        image: ghcr.io/substra/fabric-tools:0.2.4
        imagePullPolicy: "IfNotPresent"
        command: ['kubectl']
        args:
          - delete
          - secrets
          - -n
          - default
          - hlf-msp-cert-user
          - hlf-msp-key-user
          - hlf-cacert
          - hlf-tls-admin
          - hlf-tls-user
          - hlf-cacert
          - hlf-cacert
          - hlf-msp-cert-admin
          - hlf-msp-key-admin
          - ord-tls-rootcert
          - hlf-genesis
          - --ignore-not-found=true
          - --wait=true
          - -v=4
---
# Source: hlf-k8s/templates/job-hook-delete-secrets.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: my-release-hlf-k8s-hook-chaincode-delete-secrets
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-release
    helm.sh/chart: hlf-k8s-10.2.4
    app.kubernetes.io/name: hlf-k8s-hook-chaincode-delete-secrets
    app.kubernetes.io/part-of: hlf-k8s
  annotations:
    "helm.sh/hook": post-delete
    "helm.sh/hook-delete-policy": hook-succeeded
  namespace: "default"
spec:
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: 
      containers:
      - name: fabric-tools
        image: ghcr.io/substra/fabric-tools:0.2.4
        imagePullPolicy: "IfNotPresent"
        command: ['kubectl']
        args:
          - delete
          - secrets
          - -n
          - default
          - --ignore-not-found=true
          - --wait=true
          - -v=4
