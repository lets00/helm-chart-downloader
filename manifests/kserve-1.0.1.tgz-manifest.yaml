---
# Source: kserve/charts/cert-manager/templates/cainjector-serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: my-release-cert-manager-cainjector
  namespace: "default"
  labels:
    app: cainjector
    app.kubernetes.io/name: cainjector
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cainjector"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
---
# Source: kserve/charts/cert-manager/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: my-release-cert-manager
  namespace: "default"
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
---
# Source: kserve/charts/cert-manager/templates/webhook-serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: my-release-cert-manager-webhook
  namespace: "default"
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
---
# Source: kserve/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh
---
# Source: kserve/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller
---
# Source: kserve/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: kserve-controller-manager
    app.kubernetes.io/managed-by: kserve-controller-manager
    app.kubernetes.io/name: kserve-controller-manager
  name: kserve-controller-manager
---
# Source: kserve/charts/cert-manager/templates/webhook-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-cert-manager-webhook
  namespace: "default"
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
data:
---
# Source: kserve/templates/configmap.yaml
apiVersion: v1
data:
  config-defaults.yaml: |
    podsPerRuntime: 
    headlessService: true
    modelMeshImage:
      name: kserve/modelmesh
      tag: v0.8.0
    modelMeshResources:
      requests:
        cpu: "300m"
        memory: "448Mi"
      limits:
        cpu: "3"
        memory: "448Mi"
    restProxy:
      enabled: true
      port: 8008
      image:
        name: kserve/rest-proxy
        tag: v0.1.1
      resources:
        requests:
          cpu: "50m"
          memory: "96Mi"
        limits:
          cpu: "1"
          memory: "512Mi"
    storageHelperImage:
      name: kserve/modelmesh-runtime-adapter
      tag: v0.8.0
      command: ["/opt/app/puller"]
    storageHelperResources:
      requests:
        cpu: "50m"
        memory: "96Mi"
      limits:
        cpu: "2"
        memory: "512Mi"
    serviceAccountName: modelmesh
    metrics:
      enabled: true
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: model-serving-config-defaults
---
# Source: kserve/templates/configmap.yaml
apiVersion: v1
data:
  agent: |-
    {
        "image" : "kserve/agent:v0.8.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1"
    }
  batcher: |-
    {
        "image" : "kserve/agent:v0.8.0",
        "memoryRequest": "1Gi",
        "memoryLimit": "1Gi",
        "cpuRequest": "1",
        "cpuLimit": "1"
    }
  credentials: |-
    {
       "gcs": {
           "gcsCredentialFileName": "gcloud-application-credentials.json"
       },
       "s3": {
           "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",
           "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY"
       }
    }
  deploy: |-
    {
      "defaultDeploymentMode": "Serverless"
    }
  explainers: |-
    {
        "alibi": {
            "image" : "kserve/alibi-explainer",
            "defaultImageVersion": "v0.8.0"
        },
        "aix": {
            "image" : "kserve/aix-explainer",
            "defaultImageVersion": "v0.8.0"
        },
        "art": {
            "image" : "kserve/art-explainer",
            "defaultImageVersion": "v0.8.0"
        }
    }
  ingress: |-
    {
        "ingressGateway" : "knative-serving/knative-ingress-gateway",
        "ingressService" : "istio-ingressgateway.istio-system.svc.cluster.local",
        "localGateway" : "knative-serving/knative-local-gateway",
        "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",
        "ingressDomain"  : "example.com"
    }
  logger: |-
    {
        "image" : "kserve/agent:v0.8.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1",
        "defaultUrl": "http://default-broker"
    }
  predictors: |-
    {
        "tensorflow": {
            "supportedFrameworks": [
              "tensorflow"
            ],
            "multiModelServer": false
        },
        "onnx": {
            "supportedFrameworks": [
              "onnx"
            ],
            "multiModelServer": false
        },
        "sklearn": {
          "v1": {
            "supportedFrameworks": [
              "sklearn"
            ],
            "multiModelServer": true
          },
          "v2": {
            "supportedFrameworks": [
              "sklearn"
            ],
            "multiModelServer": false
          }
        },
        "xgboost": {
          "v1": {
            "supportedFrameworks": [
              "xgboost"
            ],
            "multiModelServer": true
          },
          "v2": {
            "supportedFrameworks": [
              "xgboost"
            ],
            "multiModelServer": false
          }
        },
        "pytorch": {
          "supportedFrameworks": [
            "pytorch"
          ],
          "multiModelServer": false
        },
        "triton": {
            "supportedFrameworks": [
              "tensorrt",
              "tensorflow",
              "onnx",
              "pytorch"
            ],
            "multiModelServer": true
        },
        "pmml": {
            "supportedFrameworks": [
              "pmml"
            ],
            "multiModelServer": false
        },
        "lightgbm": {
            "supportedFrameworks": [
              "lightgbm"
            ],
            "multiModelServer": false
        },
        "paddle": {
            "supportedFrameworks": [
              "paddle"
            ],
            "multiModelServer": false
        }
    }
  storageInitializer: |-
    {
        "image" : "kserve/storage-initializer:v0.8.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1"
    }
  transformers: |-
    {
    }
kind: ConfigMap
metadata:
  name: inferenceservice-config
  namespace: default
---
# Source: kserve/charts/cert-manager/templates/cainjector-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-cainjector
  labels:
    app: cainjector
    app.kubernetes.io/name: cainjector
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cainjector"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["get", "create", "update", "patch"]
  - apiGroups: ["admissionregistration.k8s.io"]
    resources: ["validatingwebhookconfigurations", "mutatingwebhookconfigurations"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["apiregistration.k8s.io"]
    resources: ["apiservices"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["apiextensions.k8s.io"]
    resources: ["customresourcedefinitions"]
    verbs: ["get", "list", "watch", "update"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# Issuer controller role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-issuers
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["issuers", "issuers/status"]
    verbs: ["update", "patch"]
  - apiGroups: ["cert-manager.io"]
    resources: ["issuers"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch", "create", "update", "delete"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# ClusterIssuer controller role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-clusterissuers
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["clusterissuers", "clusterissuers/status"]
    verbs: ["update", "patch"]
  - apiGroups: ["cert-manager.io"]
    resources: ["clusterissuers"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch", "create", "update", "delete"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# Certificates controller role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-certificates
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates", "certificates/status", "certificaterequests", "certificaterequests/status"]
    verbs: ["update", "patch"]
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates", "certificaterequests", "clusterissuers", "issuers"]
    verbs: ["get", "list", "watch"]
  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
  # admission controller enabled:
  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates/finalizers", "certificaterequests/finalizers"]
    verbs: ["update"]
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["orders"]
    verbs: ["create", "delete", "get", "list", "watch"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch", "create", "update", "delete", "patch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# Orders controller role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-orders
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["orders", "orders/status"]
    verbs: ["update", "patch"]
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["orders", "challenges"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["cert-manager.io"]
    resources: ["clusterissuers", "issuers"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["challenges"]
    verbs: ["create", "delete"]
  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
  # admission controller enabled:
  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["orders/finalizers"]
    verbs: ["update"]
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# Challenges controller role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-challenges
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  # Use to update challenge resource status
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["challenges", "challenges/status"]
    verbs: ["update", "patch"]
  # Used to watch challenge resources
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["challenges"]
    verbs: ["get", "list", "watch"]
  # Used to watch challenges, issuer and clusterissuer resources
  - apiGroups: ["cert-manager.io"]
    resources: ["issuers", "clusterissuers"]
    verbs: ["get", "list", "watch"]
  # Need to be able to retrieve ACME account private key to complete challenges
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch"]
  # Used to create events
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
  # HTTP01 rules
  - apiGroups: [""]
    resources: ["pods", "services"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch", "create", "delete", "update"]
  - apiGroups: [ "gateway.networking.k8s.io" ]
    resources: [ "httproutes" ]
    verbs: ["get", "list", "watch", "create", "delete", "update"]
  # We require the ability to specify a custom hostname when we are creating
  # new ingress resources.
  # See: https://github.com/openshift/origin/blob/21f191775636f9acadb44fa42beeb4f75b255532/pkg/route/apiserver/admission/ingress_admission.go#L84-L148
  - apiGroups: ["route.openshift.io"]
    resources: ["routes/custom-host"]
    verbs: ["create"]
  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
  # admission controller enabled:
  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["challenges/finalizers"]
    verbs: ["update"]
  # DNS01 rules (duplicated above)
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "watch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# ingress-shim controller role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-ingress-shim
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates", "certificaterequests"]
    verbs: ["create", "update", "delete"]
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates", "certificaterequests", "issuers", "clusterissuers"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "list", "watch"]
  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
  # admission controller enabled:
  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
  - apiGroups: ["networking.k8s.io"]
    resources: ["ingresses/finalizers"]
    verbs: ["update"]
  - apiGroups: ["gateway.networking.k8s.io"]
    resources: ["gateways", "httproutes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["gateway.networking.k8s.io"]
    resources: ["gateways/finalizers", "httproutes/finalizers"]
    verbs: ["update"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-view
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
    rbac.authorization.k8s.io/aggregate-to-view: "true"
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates", "certificaterequests", "issuers"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["challenges", "orders"]
    verbs: ["get", "list", "watch"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-edit
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates", "certificaterequests", "issuers"]
    verbs: ["create", "delete", "deletecollection", "patch", "update"]
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates/status"]
    verbs: ["update"]
  - apiGroups: ["acme.cert-manager.io"]
    resources: ["challenges", "orders"]
    verbs: ["create", "delete", "deletecollection", "patch", "update"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# Permission to approve CertificateRequests referencing cert-manager.io Issuers and ClusterIssuers
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-approve:cert-manager-io
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cert-manager"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["signers"]
    verbs: ["approve"]
    resourceNames: ["issuers.cert-manager.io/*", "clusterissuers.cert-manager.io/*"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# Permission to:
# - Update and sign CertificatSigningeRequests referencing cert-manager.io Issuers and ClusterIssuers
# - Perform SubjectAccessReviews to test whether users are able to reference Namespaced Issuers
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-controller-certificatesigningrequests
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cert-manager"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["certificates.k8s.io"]
    resources: ["certificatesigningrequests"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["certificates.k8s.io"]
    resources: ["certificatesigningrequests/status"]
    verbs: ["update", "patch"]
  - apiGroups: ["certificates.k8s.io"]
    resources: ["signers"]
    resourceNames: ["issuers.cert-manager.io/*", "clusterissuers.cert-manager.io/*"]
    verbs: ["sign"]
  - apiGroups: ["authorization.k8s.io"]
    resources: ["subjectaccessreviews"]
    verbs: ["create"]
---
# Source: kserve/charts/cert-manager/templates/webhook-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: my-release-cert-manager-webhook:subjectaccessreviews
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
- apiGroups: ["authorization.k8s.io"]
  resources: ["subjectaccessreviews"]
  verbs: ["create"]
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kserve-proxy-role
rules:
- apiGroups: ["authentication.k8s.io"]
  resources:
  - tokenreviews
  verbs: ["create"]
- apiGroups: ["authorization.k8s.io"]
  resources:
  - subjectaccessreviews
  verbs: ["create"]
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kserve-manager-role
rules:
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  - validatingwebhookconfigurations
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - apps
  resources:
  - deployments
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - autoscaling
  resources:
  - horizontalpodautoscalers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - create
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - networking.istio.io
  resources:
  - virtualservices
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - networking.istio.io
  resources:
  - virtualservices/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - networking.istio.io
  resources:
  - virtualservices/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.knative.dev
  resources:
  - services
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.knative.dev
  resources:
  - services/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.knative.dev
  resources:
  - services/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.kserve.io
  resources:
  - clusterservingruntimes
  - clusterservingruntimes/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.kserve.io
  resources:
  - clusterservingruntimes/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.kserve.io
  resources:
  - inferenceservices
  - inferenceservices/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.kserve.io
  resources:
  - inferenceservices/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.kserve.io
  resources:
  - servingruntimes
  - servingruntimes/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.kserve.io
  resources:
  - servingruntimes/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.kserve.io
  resources:
  - trainedmodels
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.kserve.io
  resources:
  - trainedmodels/status
  verbs:
  - get
  - patch
  - update
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-role
rules:
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - endpoints
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - namespaces
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - services
      - services/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - apps
    resources:
      - deployments
      - deployments/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - monitoring.coreos.com
    resources:
      - servicemonitors
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - inferenceservices
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - inferenceservices/finalizers
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - inferenceservices/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - predictors
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - predictors/finalizers
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - predictors/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - servingruntimes
      - servingruntimes/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - servingruntimes/status
    verbs:
      - get
      - patch
      - update
---
# Source: kserve/charts/cert-manager/templates/cainjector-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-cainjector
  labels:
    app: cainjector
    app.kubernetes.io/name: cainjector
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cainjector"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-cainjector
subjects:
  - name: my-release-cert-manager-cainjector
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-issuers
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-issuers
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-clusterissuers
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-clusterissuers
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-certificates
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-certificates
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-orders
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-orders
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-challenges
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-challenges
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-ingress-shim
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-ingress-shim
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-approve:cert-manager-io
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cert-manager"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-approve:cert-manager-io
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-controller-certificatesigningrequests
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cert-manager"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-controller-certificatesigningrequests
subjects:
  - name: my-release-cert-manager
    namespace: "default"
    kind: ServiceAccount
---
# Source: kserve/charts/cert-manager/templates/webhook-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-cert-manager-webhook:subjectaccessreviews
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: my-release-cert-manager-webhook:subjectaccessreviews
subjects:
- apiGroup: ""
  kind: ServiceAccount
  name: my-release-cert-manager-webhook
  namespace: default
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kserve-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kserve-proxy-role
subjects:
- kind: ServiceAccount
  name: kserve-controller-manager
  namespace: default
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kserve-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kserve-manager-role
subjects:
- kind: ServiceAccount
  name: kserve-controller-manager
  namespace: default
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: modelmesh-controller-role
subjects:
- kind: ServiceAccount
  name: modelmesh-controller
  namespace: default
---
# Source: kserve/charts/cert-manager/templates/cainjector-rbac.yaml
# leader election rules
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: my-release-cert-manager-cainjector:leaderelection
  namespace: kube-system
  labels:
    app: cainjector
    app.kubernetes.io/name: cainjector
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cainjector"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  # Used for leader election by the controller
  # cert-manager-cainjector-leader-election is used by the CertificateBased injector controller
  #   see cmd/cainjector/start.go#L113
  # cert-manager-cainjector-leader-election-core is used by the SecretBased injector controller
  #   see cmd/cainjector/start.go#L137
  - apiGroups: ["coordination.k8s.io"]
    resources: ["leases"]
    resourceNames: ["cert-manager-cainjector-leader-election", "cert-manager-cainjector-leader-election-core"]
    verbs: ["get", "update", "patch"]
  - apiGroups: ["coordination.k8s.io"]
    resources: ["leases"]
    verbs: ["create"]
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: my-release-cert-manager:leaderelection
  namespace: kube-system
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
  - apiGroups: ["coordination.k8s.io"]
    resources: ["leases"]
    resourceNames: ["cert-manager-controller"]
    verbs: ["get", "update", "patch"]
  - apiGroups: ["coordination.k8s.io"]
    resources: ["leases"]
    verbs: ["create"]
---
# Source: kserve/charts/cert-manager/templates/webhook-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: my-release-cert-manager-webhook:dynamic-serving
  namespace: "default"
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
rules:
- apiGroups: [""]
  resources: ["secrets"]
  resourceNames:
  - 'my-release-cert-manager-webhook-ca'
  verbs: ["get", "list", "watch", "update"]
# It's not possible to grant CREATE permission on a single resourceName.
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create"]
---
# Source: kserve/templates/role.yaml
# permissions to do leader election.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: kserve-leader-election-role
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps/status
  verbs:
  - get
  - update
  - patch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
---
# Source: kserve/templates/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-leader-election-role
rules:
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
  - get
  - list
  - update
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
---
# Source: kserve/templates/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-restricted-scc
rules:
- apiGroups:
  - security.openshift.io
  resourceNames:
  - restricted
  resources:
  - securitycontextconstraints
  verbs:
  - use
---
# Source: kserve/charts/cert-manager/templates/cainjector-rbac.yaml
# grant cert-manager permission to manage the leaderelection configmap in the
# leader election namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: my-release-cert-manager-cainjector:leaderelection
  namespace: kube-system
  labels:
    app: cainjector
    app.kubernetes.io/name: cainjector
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cainjector"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: my-release-cert-manager-cainjector:leaderelection
subjects:
  - kind: ServiceAccount
    name: my-release-cert-manager-cainjector
    namespace: default
---
# Source: kserve/charts/cert-manager/templates/rbac.yaml
# grant cert-manager permission to manage the leaderelection configmap in the
# leader election namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: my-release-cert-manager:leaderelection
  namespace: kube-system
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: my-release-cert-manager:leaderelection
subjects:
  - apiGroup: ""
    kind: ServiceAccount
    name: my-release-cert-manager
    namespace: default
---
# Source: kserve/charts/cert-manager/templates/webhook-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: my-release-cert-manager-webhook:dynamic-serving
  namespace: "default"
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: my-release-cert-manager-webhook:dynamic-serving
subjects:
- apiGroup: ""
  kind: ServiceAccount
  name: my-release-cert-manager-webhook
  namespace: default
---
# Source: kserve/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kserve-leader-election-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: leader-election-role
subjects:
- kind: ServiceAccount
  name: kserve-controller-manager
  namespace: default
---
# Source: kserve/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-leader-election-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: modelmesh-controller-leader-election-role
subjects:
- kind: ServiceAccount
  name: modelmesh-controller
---
# Source: kserve/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-restricted-scc
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: modelmesh-controller-restricted-scc
subjects:
- kind: ServiceAccount
  name: modelmesh-controller
---
# Source: kserve/charts/cert-manager/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-cert-manager
  namespace: "default"
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
spec:
  type: ClusterIP
  ports:
  - protocol: TCP
    port: 9402
    name: tcp-prometheus-servicemonitor
    targetPort: 9402
  selector:
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
---
# Source: kserve/charts/cert-manager/templates/webhook-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-cert-manager-webhook
  namespace: "default"
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
spec:
  type: ClusterIP
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: "https"
  selector:
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
---
# Source: kserve/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: kserve-webhook-server-service
  namespace: default
spec:
  ports:
    - port: 443
      targetPort: webhook-server
  selector:
    control-plane: kserve-controller-manager
---
# Source: kserve/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: kserve-controller-manager-service
  namespace: default
  labels:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
spec:
  selector:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
  ports:
  - port: 8443
    targetPort: https
    protocol: TCP
---
# Source: kserve/charts/cert-manager/templates/cainjector-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-cert-manager-cainjector
  namespace: "default"
  labels:
    app: cainjector
    app.kubernetes.io/name: cainjector
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "cainjector"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: cainjector
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: "cainjector"
  template:
    metadata:
      labels:
        app: cainjector
        app.kubernetes.io/name: cainjector
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/component: "cainjector"
        app.kubernetes.io/version: "v1.8.2"
        app.kubernetes.io/managed-by: Helm
        helm.sh/chart: cert-manager-v1.8.2
    spec:
      serviceAccountName: my-release-cert-manager-cainjector
      securityContext:
        runAsNonRoot: true
      containers:
        - name: cert-manager
          image: "quay.io/jetstack/cert-manager-cainjector:v1.8.2"
          imagePullPolicy: IfNotPresent
          args:
          - --v=2
          - --leader-election-namespace=kube-system
          env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          securityContext:
            allowPrivilegeEscalation: false
      nodeSelector:
        kubernetes.io/os: linux
---
# Source: kserve/charts/cert-manager/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-cert-manager
  namespace: "default"
  labels:
    app: cert-manager
    app.kubernetes.io/name: cert-manager
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "controller"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: cert-manager
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: "controller"
  template:
    metadata:
      labels:
        app: cert-manager
        app.kubernetes.io/name: cert-manager
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/component: "controller"
        app.kubernetes.io/version: "v1.8.2"
        app.kubernetes.io/managed-by: Helm
        helm.sh/chart: cert-manager-v1.8.2
      annotations:
        prometheus.io/path: "/metrics"
        prometheus.io/scrape: 'true'
        prometheus.io/port: '9402'
    spec:
      serviceAccountName: my-release-cert-manager
      securityContext:
        
        runAsNonRoot: true
      containers:
        - name: cert-manager
          image: "quay.io/jetstack/cert-manager-controller:v1.8.2"
          imagePullPolicy: IfNotPresent
          args:
          - --v=2
          - --cluster-resource-namespace=$(POD_NAMESPACE)
          - --leader-election-namespace=kube-system
          ports:
          - containerPort: 9402
            name: http-metrics
            protocol: TCP
          securityContext:
            allowPrivilegeEscalation: false
          env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
      nodeSelector:
        kubernetes.io/os: linux
---
# Source: kserve/charts/cert-manager/templates/webhook-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-cert-manager-webhook
  namespace: "default"
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: webhook
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: "webhook"
  template:
    metadata:
      labels:
        app: webhook
        app.kubernetes.io/name: webhook
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/component: "webhook"
        app.kubernetes.io/version: "v1.8.2"
        app.kubernetes.io/managed-by: Helm
        helm.sh/chart: cert-manager-v1.8.2
    spec:
      serviceAccountName: my-release-cert-manager-webhook
      securityContext:
        runAsNonRoot: true
      containers:
        - name: cert-manager
          image: "quay.io/jetstack/cert-manager-webhook:v1.8.2"
          imagePullPolicy: IfNotPresent
          args:
          - --v=2
          - --secure-port=10250
          - --dynamic-serving-ca-secret-namespace=$(POD_NAMESPACE)
          - --dynamic-serving-ca-secret-name=my-release-cert-manager-webhook-ca
          - --dynamic-serving-dns-names=my-release-cert-manager-webhook,my-release-cert-manager-webhook.default,my-release-cert-manager-webhook.default.svc
          ports:
          - name: https
            protocol: TCP
            containerPort: 10250
          livenessProbe:
            httpGet:
              path: /livez
              port: 6080
              scheme: HTTP
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /healthz
              port: 6080
              scheme: HTTP
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          securityContext:
            allowPrivilegeEscalation: false
          env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
      nodeSelector:
        kubernetes.io/os: linux
---
# Source: kserve/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    control-plane: modelmesh-controller
  name: modelmesh-controller
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: modelmesh-controller
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: modelmesh-controller
        app.kubernetes.io/managed-by: modelmesh-controller
        app.kubernetes.io/name: modelmesh-controller
        control-plane: modelmesh-controller
        network-policy: allow-egress
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/arch
                operator: In
                values:
                - amd64
      containers:
      - args:
        - --enable-leader-election
        command:
        - /manager
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: ETCD_SECRET_NAME
          value: model-serving-etcd
        image: kserve/modelmesh-controller:v0.8.0
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8081
          initialDelaySeconds: 15
          periodSeconds: 10
        name: manager
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8081
          initialDelaySeconds: 10
          periodSeconds: 5
        resources:
          limits:
            cpu: "1"
            memory: 512Mi
          requests:
            cpu: 50m
            memory: 96Mi
        securityContext:
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - mountPath: /etc/model-serving/config-defaults.yaml
          name: config-defaults
          readOnly: true
      serviceAccountName: modelmesh-controller
      terminationGracePeriodSeconds: 10
      volumes:
      - configMap:
          defaultMode: 420
          name: model-serving-config-defaults
        name: config-defaults
---
# Source: kserve/templates/deployment.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kserve-controller-manager
  namespace: default
  labels:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
  annotations:
    prometheus.io/scrape: 'true'
spec:
  selector:
    matchLabels:
      control-plane: kserve-controller-manager
      controller-tools.k8s.io: "1.0"
  serviceName: controller-manager-service
  template:
    metadata:
      labels:
        control-plane: kserve-controller-manager
        controller-tools.k8s.io: "1.0"
    spec:
      serviceAccountName: kserve-controller-manager
      containers:
      - name: kube-rbac-proxy
        image: gcr.io/kubebuilder/kube-rbac-proxy:v0.4.0
        args:
        - "--secure-listen-address=0.0.0.0:8443"
        - "--upstream=http://127.0.0.1:8080/"
        - "--logtostderr=true"
        - "--v=10"
        ports:
        - containerPort: 8443
          name: https
      - command:
        - /manager
        image: "kserve/kserve-controller:v0.8.0"
        imagePullPolicy: Always
        name: manager
        args:
        - "--metrics-addr=127.0.0.1:8080"
        env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: SECRET_NAME
            value: kserve-webhook-server-cert
        resources:
            limits:
              cpu: 100m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 300Mi
        ports:
        - containerPort: 9443
          name: webhook-server
          protocol: TCP
        - containerPort: 8080
          name: metrics
          protocol: TCP
        volumeMounts:
        - mountPath: /tmp/k8s-webhook-server/serving-certs
          name: cert
          readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: kserve-webhook-server-cert
---
# Source: kserve/templates/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: serving-cert
  namespace: default
spec:
  commonName: kserve-webhook-server-service.default.svc
  dnsNames:
  - kserve-webhook-server-service.default.svc
  issuerRef:
    kind: Issuer
    name: selfsigned-issuer
  secretName: kserve-webhook-server-cert
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-lgbserver
spec:
  supportedModelFormats:
    - name: lightgbm
      version: "2"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "kserve/lgbserver:v0.8.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
        - --nthread=1
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-mlserver
spec:
  supportedModelFormats:
    - name: sklearn
      version: "0"
    - name: xgboost
      version: "1"
    - name: lightgbm
      version: "3"
    - name: mlflow
      version: "1"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "docker.io/seldonio/mlserver:0.5.3"
      env:
        - name: "MLSERVER_MODEL_IMPLEMENTATION"
          value: "{{.Labels.modelClass}}"
        - name: "MLSERVER_HTTP_PORT"
          value: "8080"
        - name: "MLSERVER_GRPC_PORT"
          value: "9000"
        - name: "MODELS_DIR"
          value: "/mnt/models"
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-paddleserver
spec:
  supportedModelFormats:
    - name: paddle
      version: "2"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "kserve/paddleserver:v0.8.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-pmmlserver
spec:
  supportedModelFormats:
    - name: pmml
      version: "3"
      autoSelect: true
    - name: pmml
      version: "4"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "kserve/pmmlserver:v0.8.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-sklearnserver
spec:
  supportedModelFormats:
    - name: sklearn
      version: "1"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "kserve/sklearnserver:v0.8.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-tensorflow-serving
spec:
  supportedModelFormats:
    - name: tensorflow
      version: "1"
      autoSelect: true
    - name: tensorflow
      version: "2"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "tensorflow/serving:2.6.2"
      command: [/usr/bin/tensorflow_model_server]
      args:
        - --model_name={{.Name}}
        - --port=9000
        - --rest_api_port=8080
        - --model_base_path=/mnt/models
        - --rest_api_timeout_in_ms=60000
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-torchserve
spec:
  supportedModelFormats:
    - name: pytorch
      version: "1"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "kserve/torchserve-kfs:0.5.2"
      args:
        - torchserve
        - --start
        - --model-store=/mnt/models/model-store
        - --ts-config=/mnt/models/config/config.properties
      env:
        - name: "TS_SERVICE_ENVELOPE"
          value: "{{.Labels.serviceEnvelope}}"
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-tritonserver
spec:
  supportedModelFormats:
    - name: tensorrt
      version: "8"
    - name: tensorflow
      version: "1"
    - name: tensorflow
      version: "2"
    - name: onnx
      version: "1"
      autoSelect: true
    - name: pytorch
      version: "1"
    - name: triton
      version: "2"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "nvcr.io/nvidia/tritonserver:21.09-py3"
      args:
        - tritonserver
        - --model-store=/mnt/models
        - --grpc-port=9000
        - --http-port=8080
        - --allow-grpc=true
        - --allow-http=true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-xgbserver
spec:
  supportedModelFormats:
    - name: xgboost
      version: "1"
      autoSelect: true
  containers:
    - name: kserve-container
      image: "kserve/xgbserver:v0.8.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
        - --nthread=1
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
  namespace: default
spec:
  selfSigned: {}
---
# Source: kserve/charts/cert-manager/templates/webhook-mutating-webhook.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: my-release-cert-manager-webhook
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
  annotations:
    cert-manager.io/inject-ca-from-secret: "default/my-release-cert-manager-webhook-ca"
webhooks:
  - name: webhook.cert-manager.io
    rules:
      - apiGroups:
          - "cert-manager.io"
          - "acme.cert-manager.io"
        apiVersions:
          - "v1"
        operations:
          - CREATE
          - UPDATE
        resources:
          - "*/*"
    admissionReviewVersions: ["v1"]
    # This webhook only accepts v1 cert-manager resources.
    # Equivalent matchPolicy ensures that non-v1 resource requests are sent to
    # this webhook (after the resources have been converted to v1).
    matchPolicy: Equivalent
    timeoutSeconds: 10
    failurePolicy: Fail
    # Only include 'sideEffects' field in Kubernetes 1.12+
    sideEffects: None
    clientConfig:
      service:
        name: my-release-cert-manager-webhook
        namespace: "default"
        path: /mutate
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: inferenceservice.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: default/serving-cert
webhooks:
  - clientConfig:
      caBundle: Cg==
      service:
        name: kserve-webhook-server-service
        namespace: default
        path: /mutate-serving-kserve-io-v1beta1-inferenceservice
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.defaulter
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1beta1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferenceservices
  - clientConfig:
      caBundle: Cg==
      service:
        name: kserve-webhook-server-service
        namespace: default
        path: /mutate-pods
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.pod-mutator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    objectSelector:
      matchExpressions:
        - key: serving.kserve.io/inferenceservice
          operator: Exists
    rules:
      - apiGroups:
          - ""
        apiVersions:
          - v1
        operations:
          - CREATE
          - UPDATE
        resources:
          - pods
---
# Source: kserve/templates/servingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ServingRuntime
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    name: modelmesh-serving-mlserver-0.x-SR
  name: mlserver-0.x
spec:
  builtInAdapter:
    memBufferBytes: 134217728
    modelLoadingTimeoutMillis: 90000
    runtimeManagementPort: 8001
    serverType: mlserver
  containers:
  - env:
    - name: MLSERVER_MODELS_DIR
      value: /models/_mlserver_models/
    - name: MLSERVER_GRPC_PORT
      value: "8001"
    - name: MLSERVER_HTTP_PORT
      value: "8002"
    - name: MLSERVER_LOAD_MODELS_AT_STARTUP
      value: "false"
    - name: MLSERVER_MODEL_NAME
      value: dummy-model-fixme
    - name: MLSERVER_HOST
      value: 127.0.0.1
    image: seldonio/mlserver:0.5.2
    name: mlserver
    resources:
      limits:
        cpu: "5"
        memory: 1Gi
      requests:
        cpu: 500m
        memory: 1Gi
  grpcDataEndpoint: port:8001
  grpcEndpoint: port:8085
  multiModel: true
  supportedModelFormats:
    - name: sklearn
      version: "0"
      autoSelect: true
    - name: xgboost
      version: "1"
      autoSelect: true
    - name: lightgbm
      version: "3"
      autoSelect: true
---
# Source: kserve/templates/servingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ServingRuntime
metadata:
  annotations:
    maxLoadingConcurrency: "2"
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    name: modelmesh-serving-triton-2.x-SR
  name: triton-2.x
spec:
  builtInAdapter:
    memBufferBytes: 134217728
    modelLoadingTimeoutMillis: 90000
    runtimeManagementPort: 8001
    serverType: triton
  containers:
  - args:
    - -c
    - 'mkdir -p /models/_triton_models; chmod 777 /models/_triton_models; exec tritonserver
      "--model-repository=/models/_triton_models" "--model-control-mode=explicit"
      "--strict-model-config=false" "--strict-readiness=false" "--allow-http=true"
      "--allow-sagemaker=false" '
    command:
    - /bin/sh
    image: nvcr.io/nvidia/tritonserver:21.06.1-py3
    livenessProbe:
      exec:
        command:
        - curl
        - --fail
        - --silent
        - --show-error
        - --max-time
        - "9"
        - http://localhost:8000/v2/health/live
      initialDelaySeconds: 5
      periodSeconds: 30
      timeoutSeconds: 10
    name: triton
    resources:
      limits:
        cpu: "5"
        memory: 1Gi
      requests:
        cpu: 500m
        memory: 1Gi
  grpcDataEndpoint: port:8001
  grpcEndpoint: port:8085
  multiModel: true
  supportedModelFormats:
    - name: keras
      version: "2"
      autoSelect: true
    - name: onnx
      version: "1"
      autoSelect: true
    - name: pytorch
      version: "1"
      autoSelect: true
    - name: tensorflow
      version: "1"
      autoSelect: true
    - name: tensorflow
      version: "2"
      autoSelect: true
    - name: tensorrt
      version: "7"
      autoSelect: true
---
# Source: kserve/charts/cert-manager/templates/webhook-validating-webhook.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: my-release-cert-manager-webhook
  labels:
    app: webhook
    app.kubernetes.io/name: webhook
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "webhook"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
  annotations:
    cert-manager.io/inject-ca-from-secret: "default/my-release-cert-manager-webhook-ca"
webhooks:
  - name: webhook.cert-manager.io
    namespaceSelector:
      matchExpressions:
      - key: "cert-manager.io/disable-validation"
        operator: "NotIn"
        values:
        - "true"
      - key: "name"
        operator: "NotIn"
        values:
        - default
    rules:
      - apiGroups:
          - "cert-manager.io"
          - "acme.cert-manager.io"
        apiVersions:
          - "v1"
        operations:
          - CREATE
          - UPDATE
        resources:
          - "*/*"
    admissionReviewVersions: ["v1"]
    # This webhook only accepts v1 cert-manager resources.
    # Equivalent matchPolicy ensures that non-v1 resource requests are sent to
    # this webhook (after the resources have been converted to v1).
    matchPolicy: Equivalent
    timeoutSeconds: 10
    failurePolicy: Fail
    sideEffects: None
    clientConfig:
      service:
        name: my-release-cert-manager-webhook
        namespace: "default"
        path: /validate
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: inferenceservice.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: default/serving-cert
webhooks:
  - clientConfig:
      caBundle: Cg==
      service:
        name: kserve-webhook-server-service
        namespace: default
        path: /validate-serving-kserve-io-v1beta1-inferenceservice
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1beta1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferenceservices
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: trainedmodel.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: default/serving-cert
webhooks:
  - clientConfig:
      caBundle: Cg==
      service:
        name: kserve-webhook-server-service
        namespace: default
        path: /validate-serving-kserve-io-v1alpha1-trainedmodel
    failurePolicy: Fail
    name: trainedmodel.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - trainedmodels
---
# Source: kserve/charts/cert-manager/templates/startupapicheck-serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: my-release-cert-manager-startupapicheck
  namespace: "default"
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-5"
  labels:
    app: startupapicheck
    app.kubernetes.io/name: startupapicheck
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "startupapicheck"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
---
# Source: kserve/charts/cert-manager/templates/startupapicheck-rbac.yaml
# create certificate role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: my-release-cert-manager-startupapicheck:create-cert
  namespace: "default"
  labels:
    app: startupapicheck
    app.kubernetes.io/name: startupapicheck
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "startupapicheck"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-5"
rules:
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates"]
    verbs: ["create"]
---
# Source: kserve/charts/cert-manager/templates/startupapicheck-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: my-release-cert-manager-startupapicheck:create-cert
  namespace: "default"
  labels:
    app: startupapicheck
    app.kubernetes.io/name: startupapicheck
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "startupapicheck"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "-5"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: my-release-cert-manager-startupapicheck:create-cert
subjects:
  - kind: ServiceAccount
    name: my-release-cert-manager-startupapicheck
    namespace: default
---
# Source: kserve/charts/cert-manager/templates/startupapicheck-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: my-release-cert-manager-startupapicheck
  namespace: "default"
  labels:
    app: startupapicheck
    app.kubernetes.io/name: startupapicheck
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: "startupapicheck"
    app.kubernetes.io/version: "v1.8.2"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: cert-manager-v1.8.2
  annotations:
    helm.sh/hook: post-install
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
    helm.sh/hook-weight: "1"
spec:
  backoffLimit: 4
  template:
    metadata:
      labels:
        app: startupapicheck
        app.kubernetes.io/name: startupapicheck
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/component: "startupapicheck"
        app.kubernetes.io/version: "v1.8.2"
        app.kubernetes.io/managed-by: Helm
        helm.sh/chart: cert-manager-v1.8.2
    spec:
      restartPolicy: OnFailure
      serviceAccountName: my-release-cert-manager-startupapicheck
      securityContext:
        runAsNonRoot: true
      containers:
        - name: cert-manager
          image: "quay.io/jetstack/cert-manager-ctl:v1.8.2"
          imagePullPolicy: IfNotPresent
          args:
          - check
          - api
          - --wait=1m
          securityContext:
            allowPrivilegeEscalation: false
