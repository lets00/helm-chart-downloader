---
# Source: netbox/charts/redis/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: my-release-redis
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
---
# Source: netbox/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-release-netbox
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
---
# Source: netbox/charts/postgresql/templates/secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-release-postgresql
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-10.16.2
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
  namespace: netbox-4.1.1.tgz
type: Opaque
data:
  postgresql-postgres-password: "MWFjakF0RzNNNQ=="
  postgresql-password: "dHNJOGRENmlxeQ=="
---
# Source: netbox/charts/redis/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-release-redis
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  redis-password: "UGp3Y3Jyc3RCRw=="
---
# Source: netbox/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-release-netbox
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  email_password: ""
  napalm_password: ""
  secret_key: cm5JQ3NmS3UjP2xoWmk+MnVnIGJHKDQ+W3lmLWprMHJ4TiY/NiZ4LkNSYnRARm5HVD8pSidnRjBkKGJA
  superuser_password: YWRtaW4=
  superuser_api_token: MDEyMzQ1Njc4OWFiY2RlZjAxMjM0NTY3ODlhYmNkZWYwMTIzNDU2Nw==
---
# Source: netbox/charts/redis/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-redis-configuration
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
data:
  redis.conf: |-
    # User-supplied common configuration:
    # Enable AOF https://redis.io/topics/persistence#append-only-file
    appendonly yes
    # Disable RDB persistence, AOF persistence already enabled.
    save ""
    # End of common configuration
  master.conf: |-
    dir /data
    # User-supplied master configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of master configuration
  replica.conf: |-
    dir /data
    slave-read-only yes
    # User-supplied replica configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of replica configuration
---
# Source: netbox/charts/redis/templates/health-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-redis-health
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
data:
  ping_readiness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -n "$REDIS_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -n "$REDIS_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$response" != "PONG" ] && [ "$response" != "LOADING Redis is loading the dataset in memory" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    [[ -n "$REDIS_MASTER_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    [[ -n "$REDIS_MASTER_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$response" != "PONG" ] && [ "$response" != "LOADING Redis is loading the dataset in memory" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_readiness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_readiness_master.sh" $1 || exit_status=$?
    exit $exit_status
  ping_liveness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_liveness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_liveness_master.sh" $1 || exit_status=$?
    exit $exit_status
---
# Source: netbox/charts/redis/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-redis-scripts
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
data:
  start-master.sh: |
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    if [[ ! -f /opt/bitnami/redis/etc/master.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/master.conf /opt/bitnami/redis/etc/master.conf
    fi
    if [[ ! -f /opt/bitnami/redis/etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--requirepass" "${REDIS_PASSWORD}")
    ARGS+=("--masterauth" "${REDIS_PASSWORD}")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/master.conf")
    exec redis-server "${ARGS[@]}"
  start-replica.sh: |
    #!/bin/bash

    get_port() {
        hostname="$1"
        type="$2"

        port_var=$(echo "${hostname^^}_SERVICE_PORT_$type" | sed "s/-/_/g")
        port=${!port_var}

        if [ -z "$port" ]; then
            case $type in
                "SENTINEL")
                    echo 26379
                    ;;
                "REDIS")
                    echo 6379
                    ;;
            esac
        else
            echo $port
        fi
    }

    get_full_hostname() {
        hostname="$1"
        echo "${hostname}.${HEADLESS_SERVICE}"
    }

    REDISPORT=$(get_port "$HOSTNAME" "REDIS")

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    if [[ ! -f /opt/bitnami/redis/etc/replica.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/replica.conf /opt/bitnami/redis/etc/replica.conf
    fi
    if [[ ! -f /opt/bitnami/redis/etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi

    echo "" >> /opt/bitnami/redis/etc/replica.conf
    echo "replica-announce-port $REDISPORT" >> /opt/bitnami/redis/etc/replica.conf
    echo "replica-announce-ip $(get_full_hostname "$HOSTNAME")" >> /opt/bitnami/redis/etc/replica.conf
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--slaveof" "${REDIS_MASTER_HOST}" "${REDIS_MASTER_PORT_NUMBER}")
    ARGS+=("--requirepass" "${REDIS_PASSWORD}")
    ARGS+=("--masterauth" "${REDIS_MASTER_PASSWORD}")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/replica.conf")
    exec redis-server "${ARGS[@]}"
---
# Source: netbox/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-netbox
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
data:
  configuration.py: |
    import re
    import yaml

    from pathlib import Path

    def _deep_merge(source, destination):
      """Inspired by https://stackoverflow.com/a/20666342"""
      for key, value in source.items():
        dst_value = destination.get(key)

        if isinstance(value, dict) and isinstance(dst_value, dict):
          _deep_merge(value, dst_value)
        else:
          destination[key] = value

      return destination

    def _load_yaml():
      extraConfigBase = Path('/run/config/extra')
      configFiles = [Path('/run/config/netbox/netbox.yaml')]

      configFiles.extend(sorted(extraConfigBase.glob('*/*.yaml')))

      for configFile in configFiles:
        with open(configFile, 'r') as f:
          config = yaml.safe_load(f)

        _deep_merge(config, globals())

    def _load_secret(name, key):
      path = "/run/secrets/{name}/{key}".format(name=name, key=key)
      with open(path, 'r') as f:
        return f.read()

    _load_yaml()

    DATABASE['PASSWORD'] = _load_secret('netbox', 'db_password')
    EMAIL['PASSWORD'] = _load_secret('netbox', 'email_password')
    NAPALM_PASSWORD = _load_secret('netbox', 'napalm_password')
    REDIS['tasks']['PASSWORD'] = _load_secret('netbox', 'redis_tasks_password')
    REDIS['caching']['PASSWORD'] = _load_secret('netbox', 'redis_cache_password')
    SECRET_KEY = _load_secret('netbox', 'secret_key')

    # Post-process certain values
    CORS_ORIGIN_REGEX_WHITELIST = [re.compile(r) for r
                                   in CORS_ORIGIN_REGEX_WHITELIST]

  netbox.yaml: |
    ALLOWED_HOSTS: ["*"]

    DATABASE:
      HOST: "my-release-postgresql"
      USER: "netbox"
      NAME: "netbox"
      PORT: 5432
      OPTIONS:
        sslmode: "prefer"
        target_session_attrs: 'read-write'
      CONN_MAX_AGE: 300
      DISABLE_SERVER_SIDE_CURSORS: false

    ADMINS: []
    AUTH_PASSWORD_VALIDATORS: []
    ALLOWED_URL_SCHEMES: ["file","ftp","ftps","http","https","irc","mailto","sftp","ssh","tel","telnet","tftp","vnc","xmpp"]
    BANNER_TOP: ""
    BANNER_BOTTOM: ""
    BANNER_LOGIN: ""
    BASE_PATH: ""
    CHANGELOG_RETENTION: 90
    CUSTOM_VALIDATORS: {}
    DEFAULT_USER_PREFERENCES: {}
    CORS_ORIGIN_ALLOW_ALL: false
    CORS_ORIGIN_WHITELIST: []
    CORS_ORIGIN_REGEX_WHITELIST: []
    CSRF_TRUSTED_ORIGINS: []
    DEBUG: false

    EMAIL:
      SERVER: "localhost"
      PORT: 25
      USERNAME: ""
      USE_SSL: false
      USE_TLS: false
      SSL_CERTFILE: ""
      SSL_KEYFILE: ""
      TIMEOUT: 10
      FROM_EMAIL: ""

    ENFORCE_GLOBAL_UNIQUE: false
    EXEMPT_VIEW_PERMISSIONS: []
    FIELD_CHOICES: {}
    GRAPHQL_ENABLED: true
    HTTP_PROXIES: null
    INTERNAL_IPS: ["127.0.0.1","::1"]
    JOBRESULT_RETENTION: 90
    LOGGING: {}
    LOGIN_PERSISTENCE: false
    LOGIN_REQUIRED: false
    LOGIN_TIMEOUT: 1209600
    MAINTENANCE_MODE: false
    MAPS_URL: "https://maps.google.com/?q="
    MAX_PAGE_SIZE: 1000
    MEDIA_ROOT: /opt/netbox/netbox/media
    STORAGE_BACKEND: 
    STORAGE_CONFIG:  {}
    METRICS_ENABLED: false
    NAPALM_USERNAME: ""
    NAPALM_TIMEOUT: 30
    NAPALM_ARGS: {}
    PAGINATE_COUNT: 50
    PLUGINS: []
    PLUGINS_CONFIG: {}
    POWERFEED_DEFAULT_AMPERAGE: 15
    POWERFEED_DEFAULT_MAX_UTILIZATION: 80
    POWERFEED_DEFAULT_VOLTAGE: 120
    PREFER_IPV4: false
    RACK_ELEVATION_DEFAULT_UNIT_HEIGHT: 22
    RACK_ELEVATION_DEFAULT_UNIT_WIDTH: 220
    REMOTE_AUTH_ENABLED: false
    REMOTE_AUTH_BACKEND: "netbox.authentication.RemoteUserBackend"
    REMOTE_AUTH_HEADER: "HTTP_REMOTE_USER"
    REMOTE_AUTH_AUTO_CREATE_USER: true
    REMOTE_AUTH_DEFAULT_GROUPS: []
    REMOTE_AUTH_DEFAULT_PERMISSIONS: {}
    REMOTE_AUTH_GROUP_SYNC_ENABLED: false
    REMOTE_AUTH_GROUP_HEADER: "HTTP_REMOTE_USER_GROUP"
    REMOTE_AUTH_SUPERUSER_GROUPS: []
    REMOTE_AUTH_SUPERUSERS: []
    REMOTE_AUTH_STAFF_GROUPS: []
    REMOTE_AUTH_STAFF_USERS: []
    REMOTE_AUTH_GROUP_SEPARATOR: "|"
    RELEASE_CHECK_URL: null

    REDIS:
      tasks:
        HOST: "my-release-redis-master"
        PORT: 6379
        DATABASE: 0
        SSL: false
        INSECURE_SKIP_TLS_VERIFY: false
      caching:
        HOST: "my-release-redis-master"
        PORT: 6379
        DATABASE: 1
        SSL: false
        INSECURE_SKIP_TLS_VERIFY: false

    REPORTS_ROOT: /opt/netbox/netbox/reports
    RQ_DEFAULT_TIMEOUT: 300
    SCRIPTS_ROOT: /opt/netbox/netbox/scripts
    CSRF_COOKIE_NAME: "csrftoken"
    SESSION_COOKIE_NAME: sessionid
    TIME_ZONE: "UTC"
    DATE_FORMAT: "N j, Y"
    SHORT_DATE_FORMAT: "Y-m-d"
    TIME_FORMAT: "g:i a"
    SHORT_TIME_FORMAT: "H:i:s"
    DATETIME_FORMAT: "N j, Y g:i a"
    SHORT_DATETIME_FORMAT: "Y-m-d H:i"
---
# Source: netbox/templates/pvc-media.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: my-release-netbox-media
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "1Gi"
---
# Source: netbox/charts/postgresql/templates/svc-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-postgresql-headless
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-10.16.2
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
    # Use this annotation in addition to the actual publishNotReadyAddresses
    # field below because the annotation will stop being respected soon but the
    # field is broken in some versions of Kubernetes:
    # https://github.com/kubernetes/kubernetes/issues/58662
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  namespace: netbox-4.1.1.tgz
spec:
  type: ClusterIP
  clusterIP: None
  # We want all pods in the StatefulSet to have their addresses published for
  # the sake of the other Postgresql pods even before they're ready, since they
  # have to be able to talk to each other in order to become ready.
  publishNotReadyAddresses: true
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: my-release
---
# Source: netbox/charts/postgresql/templates/svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-postgresql
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-10.16.2
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
  annotations:
  namespace: netbox-4.1.1.tgz
spec:
  type: ClusterIP
  ports:
    - name: tcp-postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: my-release
    role: primary
---
# Source: netbox/charts/redis/templates/headless-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-redis-headless
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: my-release
---
# Source: netbox/charts/redis/templates/master/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-redis-master
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: master
spec:
  type: ClusterIP
  
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: master
---
# Source: netbox/charts/redis/templates/replicas/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-redis-replicas
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: replica
spec:
  type: ClusterIP
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: replica
---
# Source: netbox/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-netbox
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/component: netbox
---
# Source: netbox/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-netbox
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: netbox
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: netbox
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: netbox
  template:
    metadata:
      annotations:
        checksum/config: 72883173e43e3e1a025d02f4da67277cb6d6440d32db71620f93f300cef8d515
        checksum/secret: 9ae7f3ea3cf68def86da8fcbca3987845f2a1506dcc9907d940c9b0a096ca957
      labels:
        app.kubernetes.io/name: netbox
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/component: netbox
    spec:
      serviceAccountName: my-release-netbox
      securityContext:
        fsGroup: 1000
        runAsNonRoot: true
      initContainers:
        - name: init-dirs
          image: "busybox:1.32.1"
          imagePullPolicy: IfNotPresent
          command: [/bin/sh, -c, mkdir -p /opt/unit/state /opt/unit/tmp]
          securityContext:
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1000
            runAsNonRoot: true
            runAsUser: 1000
          volumeMounts:
            - name: optunit
              mountPath: /opt/unit
      containers:
        - name: netbox
          securityContext:
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1000
            runAsNonRoot: true
            runAsUser: 1000
          image: "netboxcommunity/netbox:v3.2.8"
          imagePullPolicy: IfNotPresent
          env:
            - name: SUPERUSER_NAME
              value: "admin"
            - name: SUPERUSER_EMAIL
              value: "admin@example.com"
            - name: SKIP_STARTUP_SCRIPTS
              value: "true"
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          readinessProbe:
            httpGet:
              path: /login/
              port: http
            initialDelaySeconds: 0
            timeoutSeconds: 1
            successThreshold: 1
            periodSeconds: 10
          volumeMounts:
            - name: config
              mountPath: /etc/netbox/config/configuration.py
              subPath: configuration.py
              readOnly: true
            - name: config
              mountPath: /run/config/netbox
              readOnly: true
            - name: secrets
              mountPath: /run/secrets/netbox
              readOnly: true
            - name: netbox-tmp
              mountPath: /tmp
            - name: media
              mountPath: /opt/netbox/netbox/media
              subPath: ""
            - name: optunit
              mountPath: /opt/unit
            - name: secrets
              mountPath: /run/secrets/superuser_password
              subPath: superuser_password
              readOnly: true
            - name: secrets
              mountPath: /run/secrets/superuser_api_token
              subPath: superuser_api_token
              readOnly: true
      volumes:
        - name: config
          configMap:
            name: my-release-netbox
        - name: secrets
          projected:
            sources:
              - secret:
                  name: "my-release-netbox"
                  items:
                    # Used by netbox-docker entry scripts
                    - key: superuser_password
                      path: superuser_password
                    - key: superuser_api_token
                      path: superuser_api_token
                    # Used by our configuration
                    - key: email_password
                      path: email_password
                    - key: napalm_password
                      path: napalm_password
                    - key: secret_key
                      path: secret_key
              - secret:
                  name: "my-release-postgresql"
                  items:
                    - key: "postgresql-password"
                      path: db_password
              - secret:
                  name: "my-release-redis"
                  items:
                    - key: "redis-password"
                      path: redis_tasks_password
              - secret:
                  name: "my-release-redis"
                  items:
                    - key: "redis-password"
                      path: redis_cache_password
        - name: netbox-tmp
          emptyDir:
            medium: Memory
        - name: optunit
          emptyDir:
            medium: Memory
        - name: media
          persistentVolumeClaim:
            claimName: my-release-netbox-media
---
# Source: netbox/templates/worker-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-release-netbox-worker
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: worker
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: netbox
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: worker
  template:
    metadata:
      annotations:
        checksum/config: 72883173e43e3e1a025d02f4da67277cb6d6440d32db71620f93f300cef8d515
        checksum/secret: 529b527b3a9b4c0dc5d80056a1c9183f00c2557277573f4db4ca65e2f5da5eee
      labels:
        app.kubernetes.io/name: netbox
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/component: worker
    spec:
      serviceAccountName: my-release-netbox
      securityContext:
        fsGroup: 1000
        runAsNonRoot: true
      containers:
        - name: netbox-worker
          securityContext:
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsGroup: 1000
            runAsNonRoot: true
            runAsUser: 1000
          image: "netboxcommunity/netbox:v3.2.8"
          command:
            - /opt/netbox/venv/bin/python
            - /opt/netbox/netbox/manage.py
            - rqworker
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: config
              mountPath: /etc/netbox/config/configuration.py
              subPath: configuration.py
              readOnly: true
            - name: config
              mountPath: /run/config/netbox
              readOnly: true
            - name: secrets
              mountPath: /run/secrets/netbox
              readOnly: true
            - name: netbox-tmp
              mountPath: /tmp
            - name: media
              mountPath: /opt/netbox/netbox/media
              subPath: ""
      volumes:
        - name: config
          configMap:
            name: my-release-netbox
        - name: secrets
          projected:
            sources:
              - secret:
                  name: "my-release-netbox"
                  items:
                    # Used by our configuration
                    - key: email_password
                      path: email_password
                    - key: napalm_password
                      path: napalm_password
                    - key: secret_key
                      path: secret_key
              - secret:
                  name: "my-release-postgresql"
                  items:
                    - key: "postgresql-password"
                      path: db_password
              - secret:
                  name: "my-release-redis"
                  items:
                    - key: "redis-password"
                      path: redis_tasks_password
              - secret:
                  name: "my-release-redis"
                  items:
                    - key: "redis-password"
                      path: redis_cache_password
        - name: netbox-tmp
          emptyDir:
            medium: Memory
        - name: media
          persistentVolumeClaim:
            claimName: my-release-netbox-media
---
# Source: netbox/charts/postgresql/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-release-postgresql
  labels:
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-10.16.2
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: primary
  annotations:
  namespace: netbox-4.1.1.tgz
spec:
  serviceName: my-release-postgresql-headless
  replicas: 1
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/instance: my-release
      role: primary
  template:
    metadata:
      name: my-release-postgresql
      labels:
        app.kubernetes.io/name: postgresql
        helm.sh/chart: postgresql-10.16.2
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/managed-by: Helm
        role: primary
        app.kubernetes.io/component: primary
    spec:      
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/instance: my-release
                    app.kubernetes.io/component: primary
                namespaces:
                  - "netbox-4.1.1.tgz"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      securityContext:
        fsGroup: 1001
      automountServiceAccountToken: false
      containers:
        - name: my-release-postgresql
          image: docker.io/bitnami/postgresql:11.14.0-debian-10-r28
          imagePullPolicy: "IfNotPresent"
          resources:
            requests:
              cpu: 250m
              memory: 256Mi
          securityContext:
            runAsUser: 1001
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: POSTGRESQL_PORT_NUMBER
              value: "5432"
            - name: POSTGRESQL_VOLUME_DIR
              value: "/bitnami/postgresql"
            - name: PGDATA
              value: "/bitnami/postgresql/data"
            - name: POSTGRES_POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-release-postgresql
                  key: postgresql-postgres-password
            - name: POSTGRES_USER
              value: "netbox"
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-release-postgresql
                  key: postgresql-password
            - name: POSTGRES_DB
              value: "netbox"
            - name: POSTGRESQL_ENABLE_LDAP
              value: "no"
            - name: POSTGRESQL_ENABLE_TLS
              value: "no"
            - name: POSTGRESQL_LOG_HOSTNAME
              value: "false"
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: "false"
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: "false"
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: "off"
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: "error"
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: "pgaudit"
          ports:
            - name: tcp-postgresql
              containerPort: 5432
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - exec pg_isready -U "netbox" -d "dbname=netbox" -h 127.0.0.1 -p 5432
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 6
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                - |
                  exec pg_isready -U "netbox" -d "dbname=netbox" -h 127.0.0.1 -p 5432
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 6
          volumeMounts:
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
              subPath: 
      volumes:
        - name: dshm
          emptyDir:
            medium: Memory
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: netbox/charts/redis/templates/master/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-release-redis-master
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: master
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: redis
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: master
  serviceName: my-release-redis-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis
        helm.sh/chart: redis-15.7.6
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: master
      annotations:
        checksum/configmap: 1b87291dbc1f9bd4de7e47417bbe20addf859dc4273aca5c1103f06e761aebe3
        checksum/health: 1dfef66164388c5af0be784622f107043cca7c27c21c7d2100860a261fa3a94e
        checksum/scripts: 4ca2a1eb83a22f1eaa908558e01db0b6d7ff3140a631a294214d2d8d79796faf
        checksum/secret: 025a9e7ac3709008421c542702fdbf49f1863eff7a88c43188103ce181a7ae51
    spec:
      
      securityContext:
        fsGroup: 1001
      serviceAccountName: my-release-redis
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/instance: my-release
                    app.kubernetes.io/component: master
                namespaces:
                  - "netbox-4.1.1.tgz"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:6.2.6-debian-10-r97
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          command:
            - /bin/bash
          args:
            - -c
            - /opt/bitnami/scripts/start-scripts/start-master.sh
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: REDIS_REPLICATION_MODE
              value: master
            - name: ALLOW_EMPTY_PASSWORD
              value: "no"
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-release-redis
                  key: redis-password
            - name: REDIS_TLS_ENABLED
              value: "no"
            - name: REDIS_PORT
              value: "6379"
          ports:
            - name: redis
              containerPort: 6379
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            # One second longer than command timeout should prevent generation of zombie processes.
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_liveness_local.sh 5
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_readiness_local.sh 1
          resources:
            limits: {}
            requests: {}
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-data
              mountPath: /data
              subPath: 
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: redis-tmp-conf
              mountPath: /opt/bitnami/redis/etc/
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: start-scripts
          configMap:
            name: my-release-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: my-release-redis-health
            defaultMode: 0755
        - name: config
          configMap:
            name: my-release-redis-configuration
        - name: redis-tmp-conf
          emptyDir: {}
        - name: tmp
          emptyDir: {}
  volumeClaimTemplates:
    - metadata:
        name: redis-data
        labels:
          app.kubernetes.io/name: redis
          app.kubernetes.io/instance: my-release
          app.kubernetes.io/component: master
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: netbox/charts/redis/templates/replicas/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-release-redis-replicas
  namespace: "netbox-4.1.1.tgz"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.7.6
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: replica
spec:
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: redis
      app.kubernetes.io/instance: my-release
      app.kubernetes.io/component: replica
  serviceName: my-release-redis-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis
        helm.sh/chart: redis-15.7.6
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: replica
      annotations:
        checksum/configmap: 1b87291dbc1f9bd4de7e47417bbe20addf859dc4273aca5c1103f06e761aebe3
        checksum/health: 1dfef66164388c5af0be784622f107043cca7c27c21c7d2100860a261fa3a94e
        checksum/scripts: 4ca2a1eb83a22f1eaa908558e01db0b6d7ff3140a631a294214d2d8d79796faf
        checksum/secret: 3f4322535421e83a7eba698d5c6c8fc4b03b40a1d90e86e66828666388cdb2dc
    spec:
      
      securityContext:
        fsGroup: 1001
      serviceAccountName: my-release-redis
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/instance: my-release
                    app.kubernetes.io/component: replica
                namespaces:
                  - "netbox-4.1.1.tgz"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:6.2.6-debian-10-r97
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          command:
            - /bin/bash
          args:
            - -c
            - /opt/bitnami/scripts/start-scripts/start-replica.sh
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: REDIS_REPLICATION_MODE
              value: slave
            - name: REDIS_MASTER_HOST
              value: my-release-redis-master-0.my-release-redis-headless.netbox-4.1.1.tgz.svc.cluster.local
            - name: REDIS_MASTER_PORT_NUMBER
              value: "6379"
            - name: ALLOW_EMPTY_PASSWORD
              value: "no"
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-release-redis
                  key: redis-password
            - name: REDIS_MASTER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: my-release-redis
                  key: redis-password
            - name: REDIS_TLS_ENABLED
              value: "no"
            - name: REDIS_PORT
              value: "6379"
          ports:
            - name: redis
              containerPort: 6379
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_liveness_local_and_master.sh 5
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_readiness_local_and_master.sh 1
          resources:
            limits: {}
            requests: {}
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-data
              mountPath: /data
              subPath: 
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: redis-tmp-conf
              mountPath: /opt/bitnami/redis/etc
      volumes:
        - name: start-scripts
          configMap:
            name: my-release-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: my-release-redis-health
            defaultMode: 0755
        - name: config
          configMap:
            name: my-release-redis-configuration
        - name: redis-tmp-conf
          emptyDir: {}
  volumeClaimTemplates:
    - metadata:
        name: redis-data
        labels:
          app.kubernetes.io/name: redis
          app.kubernetes.io/instance: my-release
          app.kubernetes.io/component: replica
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: netbox/templates/cronjob.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: my-release-netbox-housekeeping
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: housekeeping
spec:
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 5
  schedule: "0 0 * * *"
  successfulJobsHistoryLimit: 5
  suspend: false
  jobTemplate:
    metadata:
      labels:
        helm.sh/chart: netbox-4.1.1
        app.kubernetes.io/name: netbox
        app.kubernetes.io/instance: my-release
        app.kubernetes.io/version: "v3.2.8"
        app.kubernetes.io/managed-by: Helm
    spec:
      template:
        metadata:
          labels:
            app.kubernetes.io/name: netbox
            app.kubernetes.io/instance: my-release
            app.kubernetes.io/component: housekeeping
        spec:
          serviceAccountName: my-release-netbox
          securityContext:
            fsGroup: 1000
            runAsNonRoot: true
          containers:
            - name: netbox-housekeeping
              securityContext:
                capabilities:
                  drop:
                  - ALL
                readOnlyRootFilesystem: true
                runAsGroup: 1000
                runAsNonRoot: true
                runAsUser: 1000
              image: "netboxcommunity/netbox:v3.2.8"
              command:
                - /opt/netbox/venv/bin/python
                - /opt/netbox/netbox/manage.py
                - housekeeping
              imagePullPolicy: IfNotPresent
              volumeMounts:
                - name: config
                  mountPath: /etc/netbox/config/configuration.py
                  subPath: configuration.py
                  readOnly: true
                - name: config
                  mountPath: /run/config/netbox
                  readOnly: true
                - name: secrets
                  mountPath: /run/secrets/netbox
                  readOnly: true
                - name: netbox-tmp
                  mountPath: /tmp
                - name: media
                  mountPath: /opt/netbox/netbox/media
                  subPath: ""
          volumes:
            - name: config
              configMap:
                name: my-release-netbox
            - name: secrets
              projected:
                sources:
                  - secret:
                      name: "my-release-netbox"
                      items:
                        # Used by our configuration
                        - key: email_password
                          path: email_password
                        - key: napalm_password
                          path: napalm_password
                        - key: secret_key
                          path: secret_key
                  - secret:
                      name: "my-release-postgresql"
                      items:
                        - key: "postgresql-password"
                          path: db_password
                  - secret:
                      name: "my-release-redis"
                      items:
                        - key: "redis-password"
                          path: redis_tasks_password
                  - secret:
                      name: "my-release-redis"
                      items:
                        - key: "redis-password"
                          path: redis_cache_password
            - name: netbox-tmp
              emptyDir:
                medium: Memory
            - name: media
              persistentVolumeClaim:
                claimName: my-release-netbox-media
          restartPolicy: OnFailure
---
# Source: netbox/templates/tests/test-connection.yaml
apiVersion: v1
kind: Pod
metadata:
  name: "my-release-netbox-test-connection"
  labels:
    helm.sh/chart: netbox-4.1.1
    app.kubernetes.io/name: netbox
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "v3.2.8"
    app.kubernetes.io/managed-by: Helm
  annotations:
    "helm.sh/hook": test-success
spec:
  containers:
    - name: wget
      image: "busybox:1.32.1"
      imagePullPolicy: IfNotPresent
      command: ['wget']
      args: ['my-release-netbox:80']
  restartPolicy: Never
