---
# Source: provider/templates/network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: default
spec:
  podSelector: 
    matchLabels: {}
  policyTypes:
  - Ingress
  - Egress
---
# Source: provider/templates/cronjob.yaml
# Service account the client will use to reset the statefulset,
# by default the pods running inside the cluster can do no such things.
kind: ServiceAccount
apiVersion: v1
metadata:
  name: provider-restart
  namespace: akash-services
---
# Source: provider/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-release-provider
  namespace: provider-4.0.6.tgz
  labels:
    helm.sh/chart: provider-4.0.6
    app.kubernetes.io/name: provider
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "0.1.0"
    app.kubernetes.io/managed-by: Helm
automountServiceAccountToken: true
---
# Source: provider/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-release-provider-keys
  namespace: provider-4.0.6.tgz
type: "Opaque"
data:
  key.txt: 
  key-pass.txt:
---
# Source: provider/templates/configmap-bidscripts.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-provider-bidscripts
  namespace: provider-4.0.6.tgz
data:
  dummy: |
    dummy
---
# Source: provider/templates/configmap-boot.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-release-provider-boot
  namespace: provider-4.0.6.tgz
data:
  run.sh: |
    #!/bin/bash
    
    if [[ $AKASH_DEBUG == "true" ]]; then sleep 5000; fi
    
    set -x
    
    ##
    # Import key
    ##
    cat "$AKASH_BOOT_KEYS/key-pass.txt" | { cat ; echo ; } | provider-services --home="$AKASH_HOME" keys import --keyring-backend="$AKASH_KEYRING_BACKEND"  "$AKASH_FROM" "$AKASH_BOOT_KEYS/key.txt"
    
    ##
    # Check the Akash Node is working
    ##
    apt update && apt -yqq install curl jq bc netcat ca-certificates
    solo_ip=$(echo $AKASH_NODE | cut -d":" -f2 | cut -d"/" -f3)
    port=$(echo $AKASH_NODE | cut -d":" -f3 | cut -d"/" -f1)
    if [[ $AKASH_NODE != "http://akash-node-1:26657" ]]; then
      nc -z -v -w5 $solo_ip $port
    fi
    until [[ $(curl -s $AKASH_NODE/status | jq -r .result.sync_info.catching_up) == "false" ]]; do sleep 15; echo "Akash node not ready. Retrying";  done
    
    # Check Akash RPC node isn't running behind too much and abort if it does.
    DATE_AKASH=$(curl -s $AKASH_NODE/status | jq -r '.result.sync_info.latest_block_time')
    TS_AKASH=$(date +%s --date "$DATE_AKASH")
    TS=$(date +%s)
    DIFF=$(echo "$TS - $TS_AKASH" | bc)
    if [[ "$DIFF" -gt 30 ]]; then
      echo "Akash RPC $AKASH_NODE is running $DIFF seconds behind."
      echo "ACTION: Make sure your system time in synchronized and/or check your Akash RPC node."
      exit 1
    elif [[ "$DIFF" -lt -30 ]]; then
      echo "Akash RPC $AKASH_NODE is running $DIFF seconds ahead."
      echo "ACTION: Make sure your system time in synchronized and/or check your Akash RPC node."
      exit 1
    else
      echo "Last block Akash RPC $AKASH_NODE seen was $DIFF seconds ago => OK"
    fi
    
    ##
    # Create Provider
    ##
    
    cat <<EOT > provider.yaml
    host: https://provider.:8443
    attributes:
    info:
      email: 
      website: 
    owner: 
    EOT
    
    # Figure the provider address in case the user passes `--from=<key_name>` instead of `--from=<akash1...>` address.
    PROVIDER_ADDRESS="$(provider-services keys show $AKASH_FROM -a)"
    if [[ -z "$PROVIDER_ADDRESS" ]]; then
      echo "PROVIDER_ADDRESS variable is empty. Something went wrong"
      exit 1
    fi
    
    provider-services query provider get $PROVIDER_ADDRESS -o json
    if [[ $? -ne 0 ]]; then
      echo "Could not find provider: $PROVIDER_ADDRES on the blockchain when querying Akash RPC node: $AKASH_NODE"
      echo "Attempting to create a new provider ..."
      provider-services tx provider create provider.yaml >deploy.log 2>&1
      DEPLOY=$(cat deploy.log)
    fi
    
    if [[ $DEPLOY == *"incorrect account sequence"* ]]; then
      echo "Provider has issue talking to the node, check NODE is synced."
      exit 1
    fi
    
    if [[ $DEPLOY == *"already exists"* ]]; then
      echo "Provider already exists, continue..."
    elif [[ $DEPLOY == *"Error"* ]]; then
      echo "Error creating provider : $DEPLOY"
      exit 1
    fi
    
    echo "Checking whether provider.yaml needs to be updated on the chain ..."
    REMOTE_PROVIDER="$(provider-services query provider get $PROVIDER_ADDRESS -o json | jq | sha1sum | awk '{print $1}')"
    LOCAL_PROVIDER="$(provider-services tx provider update provider.yaml --offline --generate-only --from $PROVIDER_ADDRESS | jq -r '.body.messages[]' | jq -r 'del(."@type")' | sha1sum | awk '{print $1}')"
    if [[ "$REMOTE_PROVIDER" != "$LOCAL_PROVIDER" ]]; then
      echo "Updating provider in the blockchain ..."
      provider-services tx provider update provider.yaml >deploy.log 2>&1
      DEPLOY=$(cat deploy.log)
    
      if [[ $DEPLOY == *"insufficient fees"* ]]; then
        echo "Insufficient fees!  Change the fee settings."
        exit 1
      fi
    
      if [[ $DEPLOY == *"out of gas in location"* ]]; then
        echo "Out of gas!  Change gas/fee settings."
        exit 1
      fi
    
      if [[ $DEPLOY == *"incorrect account sequence"* ]]; then
        echo "Provider has issue talking to the node, check NODE is synced."
        exit 1
      fi
    
      if [[ $DEPLOY == *"Error"* ]]; then
        echo "Error creating provider : $DEPLOY"
        exit 1
      fi
    fi
    
    CERT_SYMLINK="${AKASH_HOME}/${PROVIDER_ADDRESS}.pem"
    CERT_REAL_PATH="/config/provider.pem"
    rm -vf "$CERT_SYMLINK"
    # provider cert is coming from the configmap
    ln -sv "$CERT_REAL_PATH" "$CERT_SYMLINK"
    # 0 = yes; otherwise do not (re-)generate new provider certificate, unless
    GEN_NEW_CERT=1
    
    # Check whether the certificate is present and valid on the blockchain
    if [[ -f "${CERT_REAL_PATH}" ]]; then
      LOCAL_CERT_SN="$(cat "${CERT_REAL_PATH}" | openssl x509 -serial -noout | cut -d'=' -f2)"
      LOCAL_CERT_SN_DECIMAL=$(echo "obase=10; ibase=16; $LOCAL_CERT_SN" | bc)
      REMOTE_CERT_STATUS="$(AKASH_OUTPUT=json provider-services query cert list --owner $PROVIDER_ADDRESS --state valid --serial $LOCAL_CERT_SN_DECIMAL | jq -r '.certificates[0].certificate.state')"
      echo "Provider certificate serial number: ${LOCAL_CERT_SN:-unknown}, status on chain: ${REMOTE_CERT_STATUS:-unknown}"
    else
      echo "${CERT_REAL_PATH} file is missing."
      GEN_NEW_CERT=0
    fi
    
    if [[ -z "$LOCAL_CERT_SN" ]]; then
      echo "LOCAL_CERT_SN variable is empty. Most likely ${CERT_REAL_PATH} file is empty or malformed."
      GEN_NEW_CERT=0
    fi
    
    if [[ "valid" != "$REMOTE_CERT_STATUS" ]]; then
      echo "No valid certificate found for provider: $PROVIDER_ADDRESS"
      GEN_NEW_CERT=0
    
      echo "It might as well be that the current certificate was expired/revoked, thus, it should be safe to delete it locally"
      # It's also a good idea to delete it as otherwise, we'd have to add `--overwrite` to `provider-services tx cert generate server` command later.
      if [[ -f "${CERT_REAL_PATH}" ]]; then
        rm -vf "${CERT_REAL_PATH}"
      fi
    fi
    
    # generate a new cert if the current one expires sooner than 7 days
    AKASH_OUTPUT=json provider-services query cert list --owner $PROVIDER_ADDRESS --state valid | jq -r '.certificates[-1].certificate.cert' | openssl base64 -A -d | openssl x509 -checkend 604800 -noout 2>/dev/null 1>&2
    rc=$?
    if [[ $rc -ne 0 ]]; then
      echo "Certificate expires in less than 7 days, so going to generate a new one."
      GEN_NEW_CERT=0
    fi
    
    if [[ "$GEN_NEW_CERT" -eq "0" ]]; then
      echo "Generating new provider certificate"
      provider-services tx cert generate server provider.
      echo "Publishing new provider certificate"
      provider-services tx cert publish server
    fi
    
    ##
    # Run daemon
    ##
    provider-services run --cluster-k8s
---
# Source: provider/templates/crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: manifests.akash.network
  # DO NOT REMOVE resource-policy annotation!
  annotations:
    "helm.sh/resource-policy": keep
spec:
  group: akash.network
  scope: Namespaced
  names:
    plural: manifests
    singular: manifest
    kind: Manifest
    shortNames:
      - mani
  versions:
    - name: v2beta1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                lease_id:
                  type: object
                  properties:
                    owner:
                      type: string
                    dseq:
                      type: string
                      format: uint64
                    gseq:
                      type: integer
                    oseq:
                      type: integer
                    provider:
                      type: string
                group:
                  type: object
                  properties:
                    name:
                      type: string
                    services:
                      type: array
                      items:
                        type: object
                        properties:
                          name:
                            type: string
                          image:
                            type: string
                          args:
                            type: array
                            items:
                              type: string
                          env:
                            type: array
                            items:
                              type: string
                          unit:
                            type: object
                            properties:
                              cpu:
                                type: number
                                format: uint32
                              memory:
                                type: string
                                format: uint64
                              storage:
                                type: array
                                items:
                                  type: object
                                  properties:
                                    size:
                                      type: string
                                      format: uint64
                                    name:
                                      type: string
                          count:
                            type: number
                            format: uint64
                          expose:
                            type: array
                            items:
                              type: object
                              properties:
                                endpoint_sequence_number:
                                  type: number
                                  format: uint32
                                ip:
                                  type: string
                                port:
                                  type: integer
                                  format: uint16
                                external_port:
                                  type: integer
                                  format: uint16
                                proto:
                                  type: string
                                service:
                                  type: string
                                global:
                                  type: boolean
                                http_options:
                                  type: object
                                  properties:
                                    max_body_size:
                                      type: integer
                                    read_timeout:
                                      type: integer
                                    send_timeout:
                                      type: integer
                                    next_tries:
                                      type: integer
                                    next_timeout:
                                      type: integer
                                    next_cases:
                                      type: array
                                      items:
                                        type: string
                                hosts:
                                  type: array
                                  items:
                                    type: string
                          params:
                            type: object
                            nullable: true
                            properties:
                              storage:
                                type: array
                                items:
                                  type: object
                                  properties:
                                    name:
                                      type: string
                                    readOnly:
                                      type: boolean
                                    mount:
                                      type: string
---
# Source: provider/templates/crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: providerhosts.akash.network
  # DO NOT REMOVE resource-policy annotation!
  annotations:
    "helm.sh/resource-policy": keep
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: akash.network
  scope: Namespaced
  names:
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: providerhosts
    # singular name to be used as an alias on the CLI and for display
    singular: providerhost
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: ProviderHost
    # shortNames allow shorter string to match your resource on the CLI
    shortNames:
      - ph
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v2beta1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                service_name:
                  type: string
                external_port:
                  type: integer
                hostname:
                  type: string
                owner:
                  type: string
                provider:
                  type: string
                dseq:
                  type: integer
                gseq:
                  type: integer
                oseq:
                  type: integer
---
# Source: provider/templates/crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: providerleasedips.akash.network
  # DO NOT REMOVE resource-policy annotation!
  annotations:
    "helm.sh/resource-policy": keep
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: akash.network
  scope: Namespaced
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v2beta1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                lease_id:
                  type: object
                  properties:
                    owner:
                      type: string
                    dseq:
                      type: string
                      format: uint64
                    gseq:
                      type: integer
                    oseq:
                      type: integer
                    provider:
                      type: string
                service_name:
                  type: string
                port:
                  type: integer
                external_port:
                  type: integer
                protocol:
                  type: string
                sharing_key:
                  type: string

  names:
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: providerleasedips
    # singular name to be used as an alias on the CLI and for display
    singular: providerleasedip
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: ProviderLeasedIP
    # shortNames allow shorter string to match your resource on the CLI
    shortNames:
      - plip
---
# Source: provider/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: my-release-provider-admin
  namespace: provider-4.0.6.tgz
subjects:
  - kind: ServiceAccount
    name: my-release-provider
    namespace: provider-4.0.6.tgz
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
---
# Source: provider/templates/cronjob.yaml
# allow getting status and patching only the one statefulset you want
# to restart
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: provider-restart
  namespace: akash-services
rules:
  - apiGroups: ["apps", "extensions"]
    resources: ["statefulsets"]
    resourceNames: ["akash-provider"]
    verbs: ["get", "patch", "list", "watch"] # "list" and "watch" are only needed
                                             # if you want to use `rollout status`
---
# Source: provider/templates/cronjob.yaml
# bind the role to the service account
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: provider-restart
  namespace: akash-services
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: provider-restart
subjects:
  - kind: ServiceAccount
    name: provider-restart
    namespace: akash-services
---
# Source: provider/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-release-provider
  namespace: provider-4.0.6.tgz
  labels:
    akash.network: "true"
    app.kubernetes.io/name: akash
    app.kubernetes.io/instance: inventory
    app.kubernetes.io/component: operator
    helm.sh/chart: provider-4.0.6
    app.kubernetes.io/name: provider
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "0.1.0"
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  ports:
  - name: api
    protocol: TCP
    port: 8443
    targetPort: api
  selector:
    app: my-release-provider
    app.kubernetes.io/name: provider
    app.kubernetes.io/instance: my-release
---
# Source: provider/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-release-provider
  namespace: provider-4.0.6.tgz
  labels:
    app: my-release-provider
    helm.sh/chart: provider-4.0.6
    app.kubernetes.io/name: provider
    app.kubernetes.io/instance: my-release
    app.kubernetes.io/version: "0.1.0"
    app.kubernetes.io/managed-by: Helm
spec:
  replicas: 1
  #strategy:
  #  type: OnDelete
  serviceName: my-release-provider
  selector:
    matchLabels:
      app: my-release-provider
      app.kubernetes.io/name: provider
      app.kubernetes.io/instance: my-release
  template:
    metadata:
      annotations:
        checksum/cm-boot: 0e3be4ecd74fe8380764ceae40b34b9e585af0536f56495cc5e603580ecbed63
        checksum/cm-bidscripts: 4b0f6f4049122bb8b759f09c12cd9610633236507c56d29e5f0f12114fda4556
      labels:
        app: my-release-provider
        app.kubernetes.io/name: provider
        app.kubernetes.io/instance: my-release
    spec:
      serviceAccountName: my-release-provider
      securityContext:
        {}
      containers:
        - name: provider
          securityContext:
            {}
          image: "ghcr.io/ovrclk/provider-services:0.1.0"
          command: ["/bin/bash", "/boot/run.sh"]
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          env:
            - name: AKASH_DEBUG
              value: "false"
            ##
            # boot config
            ##

            # location of key export. must contain two files:
            #
            # key.txt:      exported wallet key
            # key-pass.txt: password used to encrypt exported key
            - name: AKASH_BOOT_KEYS
              value: "/boot-keys"

            ##
            # cosmos-sdk client config
            ##

            # --home
            - name: AKASH_HOME
              value: "/root/.akash"

            # --from
            - name: AKASH_FROM
              value: ""

            # --node
            - name: AKASH_NODE
              value: "http://akash.c29r3.xyz:80/rpc"

            # --chain-id
            - name: AKASH_CHAIN_ID
              value: "akashnet-2"

            # --keyring-backend
            - name: AKASH_KEYRING_BACKEND
              value: "test"

            # --trust-node
            - name: AKASH_TRUST_NODE
              value: "true"

            - name: AKASH_BROADCAST_MODE
              value: "block"

            - name: AKASH_VERSION
              value: "0.1.0"

            ##
            # akash-provider ip operator config
            ##

            - name: AKASH_IP_OPERATOR
              value: "false"

            ##
            # akash-provider config
            ##

            - name: AKASH_CLUSTER_WAIT_READY_DURATION
              value: "30s"

            - name: AKASH_DEPLOYMENT_INGRESS_DOMAIN
              value: "ingress."

            - name: DEPLOYMENT_NETWORK_POLICIES_ENABLED
              value: "false"

            - name: AKASH_YES
              value: "true"

            - name: AKASH_GAS_PRICES
              value: "0.025uakt"

            - name: AKASH_GAS
              value: "auto"

            - name: AKASH_GAS_ADJUSTMENT
              value: "1.25"

            - name: AKASH_DEPLOYMENT_INGRESS_STATIC_HOSTS
              value: "true"

            - name: AKASH_DEPLOYMENT_BLOCKED_HOSTNAMES
              value: ""

            - name: AKASH_CLUSTER_NODE_PORT_QUANTITY
              value: "2500"

            # This needs to stay as it gets shown upon 'akash provider lease-status` under the forwarded_ports (nodePorts).
            # This is NOT used to connect to K8s cluster itself (6443/tcp).
            # akash-provider uses kubeconfig to connect to K8s cluster.
            - name: AKASH_CLUSTER_PUBLIC_HOSTNAME
              value: "provider."

            - name: AKASH_BID_PRICE_STRATEGY
              value: "scale"


            - name: AKASH_BID_PRICE_CPU_SCALE
              value: "0.004"

            - name: AKASH_BID_PRICE_MEMORY_SCALE
              value: "0.0016"

            - name: AKASH_BID_PRICE_ENDPOINT_SCALE
              value: ""

            - name: AKASH_BID_PRICE_STORAGE_SCALE
              value: "0.00016,beta2=0.00016"

            - name: AKASH_BID_PRICE_IP_SCALE
              value: "60"

            - name: AKASH_OVERCOMMIT_PCT_CPU
              value: "0"

            - name: AKASH_OVERCOMMIT_PCT_MEM
              value: "0"

            - name: AKASH_OVERCOMMIT_PCT_STORAGE
              value: "0"

            - name: AKASH_LOG_LEVEL
              value: "info"

            - name: AKASH_CLUSTER_K8S
              value: "true"

            - name: KUBE_CONFIG
              value: "/root/.akash/.kube/config"

            - name: AKASH_DEPLOYMENT_RUNTIME_CLASS
              value: "none"

            - name: AKASH_WITHDRAWAL_PERIOD
              value: "1h"

            - name: AKASH_MINIMUM_BALANCE
              value: "10000000"

            - name: AKASH_BID_DEPOSIT
              value: "5000000uakt"

          ports:
            - name: api
              containerPort: 8443
              protocol: TCP
          volumeMounts:
            - name: boot
              mountPath: /boot
              readOnly: true
            - name: bidscripts
              mountPath: /bidscripts
              readOnly: true
            - name: keys
              mountPath: /boot-keys
              readOnly: true
            - mountPath: /config
              name: provider-config-volume
      volumes:
        - name: boot
          configMap:
            name: my-release-provider-boot
        - name: bidscripts
          configMap:
            name: my-release-provider-bidscripts
            defaultMode: 0744
        - name: keys
          secret:
            secretName: my-release-provider-keys
        - name: provider-config-volume
          hostPath:
            path: /root/.akash/k8s-config
            type: DirectoryOrCreate
---
# Source: provider/templates/cronjob.yaml
# cronjob spec itself
apiVersion: batch/v1
kind: CronJob
metadata:
  name: akash-provider-statefulset-restart
  namespace: akash-services
spec:
  concurrencyPolicy: Forbid
  schedule: '0 8 * * *'
  jobTemplate:
    spec:
      backoffLimit: 2 # this has very low chance of failing, as all this does
                      # is prompt kubernetes to schedule new replica set for
                      # the statefulset
      activeDeadlineSeconds: 600 # timeout, makes most sense with
                                 # "waiting for rollout" variant specified below
      template:
        spec:
          serviceAccountName: provider-restart
          restartPolicy: Never
          containers:
            - name: kubectl
              image: bitnami/kubectl
              command:
                - 'kubectl'
                - 'rollout'
                - 'restart'
                - 'statefulset/akash-provider'
